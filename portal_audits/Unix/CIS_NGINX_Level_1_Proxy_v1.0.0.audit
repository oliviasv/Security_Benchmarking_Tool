#
# This script is Copyright (C) 2004-2020 and is owned by Tenable, Inc. or an Affiliate thereof.
#
# This script is released under the Tenable Subscription License and
# may not be used from within scripts released under another license
# without authorization from Tenable, Inc.
#
# See the following licenses for details:
#
# http://static.tenable.com/prod_docs/Nessus_6_SLA_and_Subscription_Agreement.pdf
#
# @PROFESSIONALFEED@
# $Revision: 1.2 $
# $Date: 2020/07/14 $
#
# description : This document implements the security configuration as recommended by the
#               CIS NGINX Benchmark v1.0.0
#
#               https://workbench.cisecurity.org/files/2275
#
#<ui_metadata>
#<display_name>CIS NGINX Benchmark v1.0.0 L1 Proxy</display_name>
#<spec>
#  <type>CIS</type>
#  <name>NGINX L1 Proxy</name>
#  <version>1.0.0</version>
#  <link>https://workbench.cisecurity.org/files/2275</link>
#</spec>
#<labels>nginx,proxy,agent,unix</labels>
#<benchmark_refs>LEVEL,CSCv6,CSCv7</benchmark_refs>
#<variables>
#  <variable>
#    <name>CLIENT_MAX_BODY_SIZE</name>
#    <default>100K</default>
#    <description>Client Max Body Size</description>
#    <info>Limiting the size of the request body helps prevent unexpectedly long or large client requests from being passed to an application to perform buffer overflow attacks.</info>
#  </variable>
#  <variable>
#    <name>LARGE_CLIENT_HEADER_BUFFERS</name>
#    <default>2 1k</default>
#    <description>Large Client Header Buffers</description>
#    <info>The large_client_header_buffers directive may assist in preventing buffer overflow attacks that leverage long URI query parameters.</info>
#  </variable>
#  <variable>
#    <name>LOGROTATE_ROTATE</name>
#    <default>13</default>
#    <description>Logrotate Rotate Number</description>
#    <info>Log files are rotated this number of times before being removed.</info>
#  </variable>
#  <variable>
#    <name>NGINX_CONFIG_DIR</name>
#    <default>/etc/nginx</default>
#    <description>NGINX configuration directory</description>
#    <info>The location of NGINX configuration files.</info>
#  </variable>
#  <variable>
#    <name>NGINX_KEY</name>
#    <default>/etc/nginx/nginx.key</default>
#    <description>NGINX key file</description>
#    <info>The location of NGINX server private key file.</info>
#  </variable>
#  <variable>
#    <name>NGINX_USER</name>
#    <default>nginx</default>
#    <description>NGINX user account</description>
#    <info>The user which the NGINX process runs as.</info>
#  </variable>
#</variables>
#</ui_metadata>

<check_type:"Unix">

<custom_item>
  system      : "Linux"
  type        : CMD_EXEC
  description : "CIS_NGINX_Level_1_Proxy_v1.0.0.audit from CIS NGINX Benchmark v1.0.0"
  info        : "NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  cmd         : "nginx -v"
  expect      : "nginx[\\s]+version[\\s]*:"
  severity    : MEDIUM
  reference   : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
</custom_item>

<if>
  <condition type:"AND">
    <custom_item>
      system      : "Linux"
      type        : CMD_EXEC
      description : "Check if NGINX installed"
      cmd         : "nginx -v"
      expect      : "nginx[\\s]+version[\\s]*:"
    </custom_item>
  </condition>

  <then>
    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "1.1.1 Ensure NGINX is installed"
      info          : "The CIS NGINX Benchmark recommends using the NGINX binary provided by your vendor for most situations.

As an alternative, packages from [nginx.org](https://nginx.org/) are available for a variety of platforms, including Linux and FreeBSD.

Rationale:

The main benefits of using NGINX packages from your vendor are:
- Ease of installation
- Dependency resolution
- Increased effectiveness of maintenance and security patches
- Q&A procedures carried out by your vendor"
      solution      : "Configure repo:

Example:

#Configure your repo
cat  /etc/yum.repos.d/nginx.repo
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/\$basearch/
gpgcheck=1
enabled=1
EOF

Download signing key:

Example:

#Download Signing Key From The Internet
curl -O https://nginx.org/keys/nginx_signing.key
#import signing key so you do not get an error installing nginx
rpm --import nginx_signing.key

Install NGNIX:

Example:

yum install nginx -y"
      reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|2,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1S,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -v"
      expect        : "nginx[\\s]+version[\\s]*:"
      dont_echo_cmd : YES
    </custom_item>

    <if>
      <condition type:"AND">
        <custom_item>
          system      : "Linux"
          type        : FILE_CHECK
          description : "1.2.1 Check for yum"
          file        : "/usr/bin/yum"
        </custom_item>
      </condition>

      <then>
        <custom_item>
          system        : "Linux"
          type          : CMD_EXEC
          description   : "1.2.1 Ensure package manager repositories are properly configured"
          info          : "Systems need to have package manager repositories properly configured to ensure they receive the latest patches and updates.

Rationale:

If a system's package manager repositories are misconfigured, important patches may not be identified, or a rogue repository could introduce compromised software."
          solution      : "Configure your package manager repositories according to your vendor.

As an alternative, package manager repositories from [nginx.org](https://nginx.org/) are available for a variety of Linux platforms."
          reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv7|3.5,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1NS,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
          see_also      : "https://workbench.cisecurity.org/files/2275"
          cmd           : "/usr/bin/yum repolist -v nginx"
          expect        : "Repo-status[\\s]*:[\\s]*enabled"
          dont_echo_cmd : YES
        </custom_item>

        <custom_item>
          system        : "Linux"
          type          : CMD_EXEC
          description   : "1.2.2 Ensure the latest software package is installed"
          info          : "As new security vulnerabilities are discovered, the corresponding fixes are implemented by your NGINX software package provider. Installing the latest software version ensures these fixes are available on your system.

Rationale:

Up-to-date software provides the best possible protection against exploitation of security vulnerabilities, such as the execution of malicious code."
          solution      : "To install the latest NGINX package, run the following command:

yum update nginx -y"
          reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv7|3.5,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1NS,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
          see_also      : "https://workbench.cisecurity.org/files/2275"
          cmd           : "/usr/bin/yum info nginx | grep 'Available Packages' | awk '{print} END {if (NR == 0) print \"none\"}'"
          expect        : "none"
          dont_echo_cmd : YES
        </custom_item>
      </then>

      <else>
        <if>
          <condition type:"AND">
            <custom_item>
              system      : "Linux"
              type        : FILE_CHECK
              description : "1.2.1 Check for apt-cache"
              file        : "/usr/bin/apt-cache"
            </custom_item>
          </condition>

          <then>
            <custom_item>
              system        : "Linux"
              type          : CMD_EXEC
              description   : "1.2.1 Ensure package manager repositories are properly configured"
              info          : "Systems need to have package manager repositories properly configured to ensure they receive the latest patches and updates.

Rationale:

If a system's package manager repositories are misconfigured, important patches may not be identified, or a rogue repository could introduce compromised software."
              solution      : "Configure your package manager repositories according to your vendor.

As an alternative, package manager repositories from [nginx.org](https://nginx.org/) are available for a variety of Linux platforms."
              reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv7|3.5,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1NS,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
              see_also      : "https://workbench.cisecurity.org/files/2275"
              cmd           : "/usr/bin/apt-cache policy | grep nginx"
              expect        : "http://nginx.org/packages"
              dont_echo_cmd : YES
            </custom_item>

            <custom_item>
              system        : "Linux"
              type          : CMD_EXEC
              description   : "1.2.2 Ensure the latest software package is installed"
              info          : "As new security vulnerabilities are discovered, the corresponding fixes are implemented by your NGINX software package provider. Installing the latest software version ensures these fixes are available on your system.

Rationale:

Up-to-date software provides the best possible protection against exploitation of security vulnerabilities, such as the execution of malicious code."
              solution      : "To install the latest NGINX package, run the following command:

yum update nginx -y"
              reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv7|3.5,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1NS,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
              see_also      : "https://workbench.cisecurity.org/files/2275"
              cmd           : "/usr/bin/apt list nginx"
              expect        : "\\[installed\\]"
              dont_echo_cmd : YES
            </custom_item>
          </then>

          <else>
            <if>
              <condition type:"AND">
                <custom_item>
                  system      : "Linux"
                  type        : FILE_CHECK
                  description : "1.2.1 Check for zypper"
                  file        : "/usr/bin/zypper"
                </custom_item>
              </condition>

              <then>
                <custom_item>
                  system        : "Linux"
                  type          : CMD_EXEC
                  description   : "1.2.1 Ensure package manager repositories are properly configured"
                  info          : "Systems need to have package manager repositories properly configured to ensure they receive the latest patches and updates.

Rationale:

If a system's package manager repositories are misconfigured, important patches may not be identified, or a rogue repository could introduce compromised software."
                  solution      : "Configure your package manager repositories according to your vendor.

As an alternative, package manager repositories from [nginx.org](https://nginx.org/) are available for a variety of Linux platforms."
                  reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv7|3.5,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1NS,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
                  see_also      : "https://workbench.cisecurity.org/files/2275"
                  cmd           : "/usr/bin/zypper repos nginx"
                  expect        : "Enabled[\\s]*:[\\s]*Yes"
                  dont_echo_cmd : YES
                </custom_item>

                <custom_item>
                  system        : "Linux"
                  type          : CMD_EXEC
                  description   : "1.2.2 Ensure the latest software package is installed"
                  info          : "As new security vulnerabilities are discovered, the corresponding fixes are implemented by your NGINX software package provider. Installing the latest software version ensures these fixes are available on your system.

Rationale:

Up-to-date software provides the best possible protection against exploitation of security vulnerabilities, such as the execution of malicious code."
                  solution      : "To install the latest NGINX package, run the following command:

yum update nginx -y"
                  reference     : "800-171|3.14.1,800-53|SI-2,CN-L3|8.1.10.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.4.4(e),CN-L3|8.5.4.1(b),CN-L3|8.5.4.1(d),CN-L3|8.5.4.1(e),CSCv7|3.4,CSCv7|3.5,CSF|ID.RA-1,CSF|PR.IP-12,ITSG-33|SI-2,LEVEL|1NS,NESA|T7.6.2,NESA|T7.7.1,NIAv2|AM38,NIAv2|AM39,NIAv2|PR9,NIAv2|SS14b,SWIFT-CSCv1|2.2"
                  see_also      : "https://workbench.cisecurity.org/files/2275"
                  cmd           : "/usr/bin/zypper info nginx"
                  expect        : "Status[\\s]*:[\\s]*up-to-date"
                  dont_echo_cmd : YES
                </custom_item>
              </then>

              <else>
                <report type:"WARNING">
                  description : "1.2.1 Ensure package manager repositories are properly configured"
                  info        : "Systems need to have package manager repositories properly configured to ensure they receive the latest patches and updates.

Rationale:

If a system's package manager repositories are misconfigured, important patches may not be identified, or a rogue repository could introduce compromised software.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
                  solution    : "Configure your package manager repositories according to your vendor.

As an alternative, package manager repositories from [nginx.org](https://nginx.org/) are available for a variety of Linux platforms."
                  reference   : "CSCv7|3.4,CSCv7|3.5,LEVEL|1NS"
                  see_also    : "https://workbench.cisecurity.org/files/2275"
                </report>

                <report type:"WARNING">
                  description : "1.2.2 Ensure the latest software package is installed"
                  info        : "As new security vulnerabilities are discovered, the corresponding fixes are implemented by your NGINX software package provider. Installing the latest software version ensures these fixes are available on your system.

Rationale:

Up-to-date software provides the best possible protection against exploitation of security vulnerabilities, such as the execution of malicious code.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
                  solution    : "To install the latest NGINX package, run the following command:

yum update nginx -y"
                  reference   : "CSCv7|3.4,CSCv7|3.5,LEVEL|1NS"
                  see_also    : "https://workbench.cisecurity.org/files/2275"
                </report>
              </else>
            </if>
          </else>
        </if>
      </else>
    </if>

    <custom_item>
      system      : "Linux"
      type        : CMD_EXEC
      description : "2.2.1 Ensure that NGINX is run using a non-privileged, dedicated service account - nginx.conf"
      info        : "The nginx user directive designates which user account nginx worker processes run under. Ensuring a non-privileged, dedicated service account is used is a defense in depth measure to limit what an attacker who compromises the account can do.

Rationale:

Running a web server under a non-privileged, dedicated service account helps mitigate the risk of lateral movement to other services or processes in the event the user account running the web services is compromised. The default user nobody is typically used for several processes, and if this is compromised, it could allow an attacker to have access to all processes running as that user."
      solution    : "Add a system account for the nginx user with a home directory of /var/cache/nginx and a shell of /sbin/nologin so it does not have the ability to log in, then add the nginx user to be used by nginx:

user add nginx -r -g nginx -d /var/cache/nginx -s /sbin/nologin

Then add the nginx user to /etc/nginx/nginx.conf by adding the user directive as shown below:

user nginx;"
      reference   : "800-171|3.1.6,800-53|AC-6(2),CSCv7|5.1,CSF|PR.AC-4,ITSG-33|AC-6(2),LEVEL|1NS,NESA|T5.1.1"
      see_also    : "https://workbench.cisecurity.org/files/2275"
      cmd         : "nginx -T | grep '^[ ]*user'"
# Note: Variable @NGINX_USER@ replaced with "nginx" in field "expect".
      expect      : "^[\\s]*user[\\s]+nginx[\\s]*;"
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : CMD_EXEC
      description : "2.2.1 Ensure that NGINX is run using a non-privileged, dedicated service account - sudo"
      info        : "The nginx user directive designates which user account nginx worker processes run under. Ensuring a non-privileged, dedicated service account is used is a defense in depth measure to limit what an attacker who compromises the account can do.

Rationale:

Running a web server under a non-privileged, dedicated service account helps mitigate the risk of lateral movement to other services or processes in the event the user account running the web services is compromised. The default user nobody is typically used for several processes, and if this is compromised, it could allow an attacker to have access to all processes running as that user."
      solution    : "Add a system account for the nginx user with a home directory of /var/cache/nginx and a shell of /sbin/nologin so it does not have the ability to log in, then add the nginx user to be used by nginx:

user add nginx -r -g nginx -d /var/cache/nginx -s /sbin/nologin

Then add the nginx user to /etc/nginx/nginx.conf by adding the user directive as shown below:

user nginx;"
      reference   : "CSCv7|5.1,LEVEL|1NS"
      see_also    : "https://workbench.cisecurity.org/files/2275"
# Note: Variable @NGINX_USER@ replaced with "nginx" in field "cmd".
      cmd         : "sudo -l -U nginx 2>&1"
      expect      : "(not allowed to run sudo|command not found)"
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : CMD_EXEC
      description : "2.2.1 Ensure that NGINX is run using a non-privileged, dedicated service account - groups"
      info        : "The nginx user directive designates which user account nginx worker processes run under. Ensuring a non-privileged, dedicated service account is used is a defense in depth measure to limit what an attacker who compromises the account can do.

Rationale:

Running a web server under a non-privileged, dedicated service account helps mitigate the risk of lateral movement to other services or processes in the event the user account running the web services is compromised. The default user nobody is typically used for several processes, and if this is compromised, it could allow an attacker to have access to all processes running as that user."
      solution    : "Add a system account for the nginx user with a home directory of /var/cache/nginx and a shell of /sbin/nologin so it does not have the ability to log in, then add the nginx user to be used by nginx:

user add nginx -r -g nginx -d /var/cache/nginx -s /sbin/nologin

Then add the nginx user to /etc/nginx/nginx.conf by adding the user directive as shown below:

user nginx;"
      reference   : "CSCv7|5.1,LEVEL|1NS"
      see_also    : "https://workbench.cisecurity.org/files/2275"
# Note: Variable @NGINX_USER@ replaced with "nginx" in field "cmd".
      cmd         : "groups nginx"
      expect      : "^[\\s]*nginx[\\s]*:[\\s]*[^\\s]+[\\s]*$"
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.2.2 Ensure the NGINX service account is locked"
      info          : "The nginx user account should have a valid password, but the account should be locked.

NOTE: If a different account is used to run nginx, that account's name should be substituted for nginx in the audit and remediation procedures.

Rationale:

As a defense-in-depth measure, the nginx user account should be locked to prevent logins and to prevent someone from switching users to nginx using the password. In general, there shouldn't be a need for anyone to have to su as nginx, and when there is a need, sudo should be used instead, which would not require the nginx account password."
      solution      : "Use the 'passwd' command to lock the nginx service account:

passwd -l nginx"
      reference     : "CSCv7|5.1,LEVEL|1S"
      see_also      : "https://workbench.cisecurity.org/files/2275"
# Note: Variable @NGINX_USER@ replaced with "nginx" in field "cmd".
      cmd           : "passwd -S nginx"
      expect        : "nginx[\\s]+(L|LK)[\\s]+"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : FILE_CONTENT_CHECK
      description : "2.2.3 Ensure the NGINX service account has an invalid shell"
      info        : "The nginx account should not have the ability to log in, so the /sbin/nologin shell should be set for the account.

Rationale:

The account used for nginx should only be used for the nginx service and does not need to have the ability to log in. This prevents an attacker who compromises the account to log in with it."
      solution    : "Change the login shell for the nginx account to /sbin/nologin by using the following command:

chsh -s /sbin/nologin nginx"
      reference   : "800-171|3.1.5,800-53|AC-6,CN-L3|7.1.3.2(b),CN-L3|7.1.3.2(g),CN-L3|8.1.10.6(a),CN-L3|8.1.4.2(d),CSCv7|5.1,CSF|PR.AC-4,CSF|PR.DS-5,ITSG-33|AC-6,LEVEL|1S,NESA|T5.1.1,NESA|T5.2.2,NESA|T5.4.1,NESA|T5.4.4,NESA|T5.4.5,NESA|T5.5.4,NESA|T5.6.1,NESA|T7.5.3,NIAv2|AM1,NIAv2|AM23f,NIAv2|SS13c,NIAv2|SS15c,PCI-DSSv3.1|7.1.2,PCI-DSSv3.2|7.1.2,SWIFT-CSCv1|5.1,TBA-FIISB|31.4.2,TBA-FIISB|31.4.3"
      see_also    : "https://workbench.cisecurity.org/files/2275"
      file        : "/etc/passwd"
# Note: Variable @NGINX_USER@ replaced with "nginx" in field "regex".
      regex       : "^nginx:"
# Note: Variable @NGINX_USER@ replaced with "nginx" in field "expect".
      expect      : "^nginx:.*:/sbin/nologin$"
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : FILE_CHECK
      description : "2.3.1 Ensure NGINX directories and files are owned by root"
      info        : "The owner and group of the /etc/nginx directory and its files should be root.

Rationale:

Setting ownership to only those users in the root group and the root user will reduce the likelihood of unauthorized modifications to the nginx configuration files."
      solution    : "Run the following command to ensure ownership and group ownership is set to root:

chown -R root:root /etc/nginx"
      reference   : "800-171|3.4.2,800-53|CM-6,CN-L3|8.1.10.6(d),CSCv7|5.1,CSF|PR.IP-1,ITSG-33|CM-6,LEVEL|1S,NESA|T3.2.1,PCI-DSSv3.1|2.2.4,PCI-DSSv3.2|2.2.4,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/files/2275"
# Note: Variable @NGINX_CONFIG_DIR@ replaced with "/etc/nginx" in field "file".
      file        : "/etc/nginx"
      owner       : "root"
      group       : "root"
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.3.2 Ensure access to NGINX directories and files is restricted"
      info          : "Permissions on the /etc/nginx directory should enforce the principle of least privilege.

Rationale:

This ensures that only users who need access to configuration files are able to view them, thus preventing unauthorized access. Other users will need to use sudo in order to access these files."
      solution      : "To set permissions to least privilege on the nginx configuration files, issue these commands:

find /etc/nginx -type d | xargs chmod 750
find /etc/nginx -type f | xargs chmod 640"
      reference     : "800-171|3.1.6,800-53|AC-6(2),CSCv6|14,CSF|PR.AC-4,ITSG-33|AC-6(2),LEVEL|1S,NESA|T5.1.1"
      see_also      : "https://workbench.cisecurity.org/files/2275"
# Note: Variable @NGINX_CONFIG_DIR@ replaced with "/etc/nginx" in field "cmd".
      cmd           : "find /etc/nginx -perm /o=rwx -exec ls -ld {} \\; | awk '{print} END {if (NR == 0) print \"none\"}'"
      expect        : "none"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : FILE_CHECK
      description : "2.3.3 Ensure the NGINX process ID (PID) file is secured"
      info        : "The PID file stores the main process ID of the nginx process. This file should be protected from unauthorized modification.

Rationale:

The PID file should be owned by root and the group root. It should also be readable to everyone, but only writable by root (permissions 644). This will prevent unauthorized modification of the PID file, which could cause a denial of service."
      solution    : "If the PID file is not owned by root, issue this command:

chown root:root /var/run/nginx.pid

If the PID file has permissions greater than 644, issue this command:

chown 644 /var/run/nginx.pid"
      reference   : "800-171|3.4.2,800-53|CM-6,CN-L3|8.1.10.6(d),CSCv7|5.1,CSF|PR.IP-1,ITSG-33|CM-6,LEVEL|1S,NESA|T3.2.1,PCI-DSSv3.1|2.2.4,PCI-DSSv3.2|2.2.4,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/files/2275"
      file        : "/var/run/nginx.pid"
      owner       : "root"
      group       : "root"
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.4.1 Ensure NGINX only listens for network connections on authorized ports"
      info          : "NGINX can be configured to listen on any port, but it should be configured to listen on authorized ports only.

Rationale:

Limiting the listening ports to only those that are authorized helps to ensure no unauthorized services are running through the use of nginx.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
      solution      : "If any ports are listening that are not authorized, comment out or delete the associated configuration for that listener."
      reference     : "CSCv7|5.1,LEVEL|1NS"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*listen[ ]*' | awk '{print} END {if (NR == 0) print \"none\"}'"
      expect        : "Manual Review Required"
      dont_echo_cmd : YES
      severity      : MEDIUM
    </custom_item>

    <report type:"WARNING">
      description : "2.4.2 Ensure requests for unknown host names are rejected"
      info        : "Your host header should be part of a predefined whitelist of known good hosts, which enables blocking access to other hosts. You should treat the host header as another input to be validated, as it is defined by the user agent.

Rationale:

Whitelisting specific hosts and blocking access to all other hosts, you help to mitigate host header injection attacks against your server. Such attacks could be used by an attacker to redirect you to a rogue host and execute scripts or get you to input credentials.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
      solution    : "Ensure your first server block mirrors the below in your nginx configuration, either at /etc/nginx/nginx.conf or any included file within your nginx config:

server {
 return 404;
}

Then investigate each server block to ensure the server_name directive is explicitly defined. Each server block should look similar to the below with the defined hostname of the associated server block in the server_name directive. For example, if your server is cisecurity.org, the configuration should look like the below example:

server {
 listen 443;
 server_name cisecurity.org;
 .....
}"
      reference   : "CSCv7|5.1,LEVEL|1NS"
      see_also    : "https://workbench.cisecurity.org/files/2275"
    </report>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.4.3 Ensure keepalive_timeout is 10 seconds or less, but not 0"
      info          : "Persistent connections are leveraged by all modern browsers to facilitate greater web performance. The keep-alive timeout limits the time a persistent connection may remain open. Setting the keep-alive timeout allows this timeout to be controlled on the server side.

Rationale:

Setting a keep-alive timeout on the server side helps mitigate denial of service attacks that establish too many persistent connections, exhausting server resources."
      solution      : "Find the HTTP or server block of your nginx configuration, and add the keepalive_timeout directive. Set it to 10 seconds or less, but not 0. This example command sets it to 10 seconds:

keepalive_timeout 10;"
      reference     : "800-171|3.1.11,800-53|AC-12,CN-L3|7.1.2.2(d),CN-L3|7.1.3.7(b),CN-L3|8.1.4.1(b),CSCv7|5.1,ITSG-33|AC-12,LEVEL|1S,NIAv2|NS49"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*keepalive_timeout[ ]*'"
      expect        : "^[\\s]*keepalive_timeout[\\s]+(10|[0-9]);"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.4.4 Ensure send_timeout is set to 10 seconds or less, but not 0"
      info          : "The send_timeout directive sets a timeout for transmitting a response to the client between two successive write operations.

Rationale:

Setting the send_timeout directive on the server side helps mitigate slow HTTP denial of service attacks by ensuring write operations taking up large amounts of time are closed."
      solution      : "Find the HTTP or server block of your nginx configuration, and add the send_timeout directive. Set it to 10 seconds or less, but not 0.

send_timeout 10;"
      reference     : "800-171|3.1.11,800-53|AC-12,CN-L3|7.1.2.2(d),CN-L3|7.1.3.7(b),CN-L3|8.1.4.1(b),ITSG-33|AC-12,LEVEL|1S,NIAv2|NS49"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*send_timeout[ ]*'"
      expect        : "^[\\s]*send_timeout[\\s]+(10|[0-9]);"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.5.2 Ensure default error and index.html pages do not reference NGINX"
      info          : "The default error and index.html pages for NGINX reveal that the server is NGINX. These default pages should be removed or modified so they do not advertise the underlying infrastructure of the server.

Rationale:

By gathering information about the server, attackers can target attacks against its known vulnerabilities. Removing pages that disclose the server runs NGINX helps reduce targeted attacks on the server."
      solution      : "Edit '/usr/share/nginx/html/index.html' and 'usr/share/nginx/html/50x.html' and remove any lines that reference 'NGINX'."
      reference     : "800-171|3.4.6,800-171|3.4.7,800-53|CM-7,CN-L3|7.1.3.5(c),CN-L3|7.1.3.7(d),CN-L3|8.1.4.4(b),CSCv7|5.1,CSF|PR.IP-1,CSF|PR.PT-3,ITSG-33|CM-7,LEVEL|1S,NIAv2|SS13b,NIAv2|SS14a,NIAv2|SS14c,NIAv2|SS15a,SWIFT-CSCv1|2.3"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "grep -i nginx /usr/share/nginx/html/*.html | awk '{print} END {if (NR == 0) print \"none\"}'"
      expect        : "none"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.5.4 Ensure the NGINX reverse proxy does not enable information disclosure - X-Powered-By"
      info          : "The server and x-powered-by header may specify the underlying technology used by an application. The NGINX reverse proxy may pass these headers if not explicitly directed to remove them.

Rationale:

Attackers can conduct reconnaissance on a website using these response headers, then target attacks for specific known vulnerabilities associated with the underlying technologies. Removing these headers will reduce the likelihood of targeted attacks."
      solution      : "Implement the below directives as part of your location block. Edit '/etc/nginx/nginx.conf' and add the following:

location /docs {
....
proxy_hide_header X-Powered-By;
proxy_hide_header Server;
....
}"
      reference     : "800-171|3.4.6,800-171|3.4.7,800-53|CM-7,CN-L3|7.1.3.5(c),CN-L3|7.1.3.7(d),CN-L3|8.1.4.4(b),CSCv7|5.1,CSF|PR.IP-1,CSF|PR.PT-3,ITSG-33|CM-7,LEVEL|1S,NIAv2|SS13b,NIAv2|SS14a,NIAv2|SS14c,NIAv2|SS15a,SWIFT-CSCv1|2.3"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*proxy_hide_header[ ]*'"
      expect        : "^[\\s]*proxy_hide_header[\\s]+X-Powered-By[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "2.5.4 Ensure the NGINX reverse proxy does not enable information disclosure - Server"
      info          : "The server and x-powered-by header may specify the underlying technology used by an application. The NGINX reverse proxy may pass these headers if not explicitly directed to remove them.

Rationale:

Attackers can conduct reconnaissance on a website using these response headers, then target attacks for specific known vulnerabilities associated with the underlying technologies. Removing these headers will reduce the likelihood of targeted attacks."
      solution      : "Implement the below directives as part of your location block. Edit '/etc/nginx/nginx.conf' and add the following:

location /docs {
....
proxy_hide_header X-Powered-By;
proxy_hide_header Server;
....
}"
      reference     : "800-171|3.4.6,800-171|3.4.7,800-53|CM-7,CN-L3|7.1.3.5(c),CN-L3|7.1.3.7(d),CN-L3|8.1.4.4(b),CSCv7|5.1,CSF|PR.IP-1,CSF|PR.PT-3,ITSG-33|CM-7,LEVEL|1S,NIAv2|SS13b,NIAv2|SS14a,NIAv2|SS14c,NIAv2|SS15a,SWIFT-CSCv1|2.3"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*proxy_hide_header[ ]*'"
      expect        : "^[\\s]*proxy_hide_header[\\s]+Server[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <report type:"WARNING">
      description : "3.1 Ensure detailed logging is enabled"
      info        : "System logging should be configured to meet your organizational security and privacy policies. Enabling detailed logging to include information about events, event sources, timestamps, and users may assist in incident response activities.

NOTE: Aim to keep sensitive information out of logs. For example, keep sensitive information out of query strings and URIs to avoid this.

Rationale:

Performing detailed logging ensures that incident responders, auditors, and others are able to clearly view the activity that has occurred on your server.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
      solution    : "Edit the log format directive in /etc/nginx/nginx.conf so it logs everything needed to meet your organizational policies.

The following variables may be considered as useful examples include in your log_format with descriptive logging. You should consult the NGINX documentation and your organizational policy to ensure you are logging sufficient information and removing sensitive information where needed.

$remote_addr - client address
$remote_user - the user if basic authentication is used
$status - the HTTP response status
$content_type - Content-Type request header field
$time_local - local time in the Common Log Format
$request_method - request method, usually GET or POST
$request - full original request line
$uri - normalized URI in request
$server_port - port of the server which accepted a request
$server_name - name of the server which accepted a request
$http_user_agent - user agent of the client requesting access
$http_x_forwarded_for - client address a proxy or load balancer is forwarding traffic for"
      reference   : "CSCv7|6.3,LEVEL|1NS"
      see_also    : "https://workbench.cisecurity.org/files/2275"
    </report>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "3.2 Ensure access logging is enabled"
      info          : "The access_log directive should be on for every core site. It is enabled by default.

Rationale:

Access logging allows incident responders and auditors to investigate access to a system in the event of an incident."
      solution      : "Ensure the access_log directive is configured for every core site your organization requires logging for.

This should look similar to the below configuration snippet. You may use different log file locations based on your needs.

access_log /var/log/nginx/host.access.log main;"
      reference     : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv7|6.3,CSF|PR.PT-1,ITSG-33|AU-3,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,SWIFT-CSCv1|6.4"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*access_log[ ]*off' | awk '{print} END {if (NR == 0) print \"none\"}'"
      expect        : "none"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "3.3 Ensure error logging is enabled and set to the info logging level"
      info          : "All errors for applications should be logged.

Rationale:

Error logging can be useful in identifying an attacker attempting to exploit a system and recreating an attacker's steps. Error logging also helps with identifying possible issues with an application."
      solution      : "Edit /etc/nginx/nginx.conf so the error_log directive is present and not commented out. The error_log should be configured to the logging location of your choice. The configuration should look similar to the below:

error_log /var/log/nginx/error.log info;"
      reference     : "800-171|3.3.1,800-171|3.3.2,800-53|AU-3,CN-L3|7.1.2.3(a),CN-L3|7.1.2.3(b),CN-L3|7.1.3.3(a),CN-L3|8.1.4.3(b),CSCv7|6.3,CSF|PR.PT-1,ITSG-33|AU-3,LEVEL|1S,NESA|T3.6.2,NIAv2|AM34a,NIAv2|AM34b,NIAv2|AM34c,NIAv2|AM34d,NIAv2|AM34e,NIAv2|AM34f,NIAv2|AM34g,SWIFT-CSCv1|6.4"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*error_log[ ]*'"
      expect        : "^[\\s]*error_log[\\s]+[^\\s]+[\\s]+info[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : FILE_CONTENT_CHECK
      description : "3.4 Ensure log files are rotated - weekly"
      info        : "Log rotation ensures log files do not consume excessive disk space, potentially causing a denial of service.

Rationale:

Log files are important to track activity that occurs on your server, but they take up significant amounts of space. Log rotation should be configured in order to ensure the logs do not consume so much disk space that logging becomes unavailable."
      solution    : "Follow the below procedure to change the default configuration to the recommended log rotation configuration. You may need to manually edit or change the below command if the configuration is not the default.

To change log compression from daily to weekly:

sed -i 's/daily/weekly/' /etc/logrotate.d/nginx

To change log rotation from every year to every 13 weeks:

sed -i 's/rotate 52/rotate 13/' /etc/logrotate.d/nginx"
      reference   : "800-53|AU-11,CSCv6|6.3,CSCv7|6.4,CSF|PR.PT-1,ITSG-33|AU-11,LEVEL|1S,NESA|M5.2.3,NESA|T3.6.2,NIAv2|SM7"
      see_also    : "https://workbench.cisecurity.org/files/2275"
      file        : "/etc/logrotate.d/nginx"
      regex       : "^[\\s]*weekly"
      expect      : "^[\\s]*weekly[\\s]*$"
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : FILE_CONTENT_CHECK
      description : "3.4 Ensure log files are rotated - rotate"
      info        : "Log rotation ensures log files do not consume excessive disk space, potentially causing a denial of service.

Rationale:

Log files are important to track activity that occurs on your server, but they take up significant amounts of space. Log rotation should be configured in order to ensure the logs do not consume so much disk space that logging becomes unavailable."
      solution    : "Follow the below procedure to change the default configuration to the recommended log rotation configuration. You may need to manually edit or change the below command if the configuration is not the default.

To change log compression from daily to weekly:

sed -i 's/daily/weekly/' /etc/logrotate.d/nginx

To change log rotation from every year to every 13 weeks:

sed -i 's/rotate 52/rotate 13/' /etc/logrotate.d/nginx"
      reference   : "800-53|AU-11,CSCv6|6.3,CSCv7|6.4,CSF|PR.PT-1,ITSG-33|AU-11,LEVEL|1S,NESA|M5.2.3,NESA|T3.6.2,NIAv2|SM7"
      see_also    : "https://workbench.cisecurity.org/files/2275"
      file        : "/etc/logrotate.d/nginx"
      regex       : "^[\\s]*rotate"
# Note: Variable @LOGROTATE_ROTATE@ replaced with "13" in field "expect".
      expect      : "^[\\s]*rotate[\\s]+13[\\s]*$"
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "3.7 Ensure proxies pass source IP information - X-Real-IP"
      info          : "The x-forwarded-for and remote address headers help identify and separate the originating client IP address of the user agent and the proxy IP address. The two types of addresses are the same, and one should always be present.

Rationale:

Being able to identify the originating client IP address can help auditors or incident responders identify where the corresponding user came from. This may be useful in the event of an attack to analyze if the IP address is a good candidate for blocking. It may also be useful to correlate an attacker's actions."
      solution      : "To ensure your proxy or load balancer will forward information about the client and the proxy to the application, you must set the below headers in your location block. Edit your location block so it shows the proxy_set_header directives for the client and the proxy as shown below. These headers are the exact same and there is no need to have both present.

server {
 ...
 location / {
 proxy_pass (Insert Application URL here);
 proxy_set_header X-Real-IP $remote_addr;
 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
 }
}"
      reference     : "CSCv6|6.4,CSCv7|6.7,LEVEL|1S"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*X-Real-IP[ ]*'"
      expect        : "^[\\s]*proxy_set_header[\\s]+X-Real-IP[\\s]+\\$remote_addr[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "3.7 Ensure proxies pass source IP information"
      info          : "The x-forwarded-for and remote address headers help identify and separate the originating client IP address of the user agent and the proxy IP address. The two types of addresses are the same, and one should always be present.

Rationale:

Being able to identify the originating client IP address can help auditors or incident responders identify where the corresponding user came from. This may be useful in the event of an attack to analyze if the IP address is a good candidate for blocking. It may also be useful to correlate an attacker's actions."
      solution      : "To ensure your proxy or load balancer will forward information about the client and the proxy to the application, you must set the below headers in your location block. Edit your location block so it shows the proxy_set_header directives for the client and the proxy as shown below. These headers are the exact same and there is no need to have both present.

server {
 ...
 location / {
 proxy_pass (Insert Application URL here);
 proxy_set_header X-Real-IP $remote_addr;
 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
 }
}"
      reference     : "CSCv6|6.4,CSCv7|6.7,LEVEL|1S"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*X-Forwarded-For[ ]*'"
      expect        : "^[\\s]*proxy_set_header[\\s]+X-Forwarded-For[\\s]+\\$proxy_add_x_forwarded_for[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.1 Ensure HTTP is redirected to HTTPS"
      info          : "Browsers and clients establish encrypted connections with servers by leveraging HTTPS. Requests leveraging HTTP are unencrypted. Unencrypted requests should be redirected so they are encrypted. Any listening HTTP port on your web server should redirect to a server profile that uses encryption. The default HTTP (unencrypted) port is 80.

Rationale:

Redirecting user agent traffic to HTTPS helps to ensure all user traffic is encrypted. Modern browsers alert users that your website is insecure when HTTPS is not used. This can decrease user trust in your website and ultimately result in decreased use of your web services. Redirection from HTTP to HTTPS couples security with usability; users are able to access your website even if they lack the security awareness to use HTTPS over HTTP when requesting your website."
      solution      : "Edit your web server or proxy configuration file to redirect all unencrypted listening ports, such as port 80, using a redirection through the return directive (cisecurity.org is used as an example server name).

server {
 listen 80;

 server_name cisecurity.org;

 return 301 https://$host$request_uri;
}"
      reference     : "800-171|3.13.11,800-53|SC-13,CSCv7|14.4,CSCv7|5.1,CSF|PR.DS-5,ISO/IEC-27001|A.10.1.1,ITSG-33|SC-13,LEVEL|1S,NESA|M5.2.6,NESA|T7.4.1,NIAv2|CY3,NIAv2|CY4,NIAv2|CY5b,NIAv2|CY5c,NIAv2|CY5d,NIAv2|CY7,NIAv2|NS5e"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*return[ ]*'"
      expect        : "^[\\s]*return[\\s]+[0-9]+[\\s]+https://.*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.2 Ensure a trusted certificate and trust chain is installed"
      info          : "Certificates and their trust chains are needed to establish the identity of a web server as legitimate and trusted. Certificate authorities validate a web server's identity and that you are the owner of that web server domain name.

Rationale:

Without a certificate and full trust chain installed on your web server, modern browsers will flag your web server as untrusted.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
      solution      : "Use the following procedure to install a certificate and its signing certificate chain onto your web server, load balancer, or proxy.

**Step 1:** Create the server's private key and a certificate signing request.

The following command will create your certificate's private key with 2048-bit key strength. Optionally, this parameter may be changed to 4096 for greater security. It will also output your certificate signing request to the nginx.csr file in your present working directory.

openssl req -new -newkey rsa:2048 -keyout nginx.key -out nginx.csr

Enter the below information about your private key:

Country Name (2 letter code) [XX]: Your Country
State or Province Name (full name) []: Your State
Locality Name (eg, city) [Default City]: Your City
Organization Name (eg, company) [Default Company Ltd]: Your City
Organizational Unit Name (eg, section) []: Your Organizational Unit
Common Name (eg, your name or your server's hostname) []: Your server's DNS name
Email Address []: Your email address

**Step 2:** Obtain a signed certificate from your certificate authority.

Provide your chosen certificate authority with your certificate signing request. Follow your certificate authority's signing procedures in order to obtain a certificate and the certificate's trust chain. A full trust chain is typically delivered in .pem format.

**Step 3:** Install certificate and signing certificate chain on your web server.

Place the .pem file from your certificate authority into the directory of your choice. Locate your created key file from the command you used to generate your certificate signing request. Open your website configuration file and edit your encrypted listener to leverage the ssl_certificate and ssl_certificate_key directives for a web server as shown below. You should also inspect include files inside your nginx.conf. This should be part of the server block.

server {
 listen 443 ssl http2;
 listen [::]:443 ssl http2;
 ssl_certificate /etc/nginx/cert.crt;
 ssl_certificate_key /etc/nginx/nginx.key;
 ...
 }

After editing this file, you must recycle nginx services for these changes to take effect. This can be done with the following command:

sudo service nginx restart"
      reference     : "800-53|SC-17,CSCv6|14.2,CSCv7|14.4,ITSG-33|SC-17,LEVEL|1NS,NESA|T7.4.2,NIAv2|CY10,NIAv2|CY12,NIAv2|CY5a,NIAv2|SS25"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*ssl_certificate[ ]*'"
      expect        : "Manual Review Required"
      dont_echo_cmd : YES
      severity      : MEDIUM
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : FILE_CHECK
      description : "4.1.3 Ensure private key permissions are restricted"
      info        : "The server's private key should be protected from unauthorized access by limiting access based on the principle of least privilege.

Rationale:

A server's private key file should be restricted to 400 permissions. This ensures only the owner of the private key file can access it. This is the minimum necessary permissions for the server to operate. If the private key file is not protected, an unauthorized user with access to the server may be able to find the private key file and use it to decrypt traffic sent to your server.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
      solution    : "Run the following command on your key file to ensure its permissions are set to 400. The file name /etc/nginx/nginx.key should be replaced with the location of your key file.

sudo chmod 400 /etc/nginx/nginx.key"
      reference   : "800-171|3.4.2,800-53|CM-6,CN-L3|8.1.10.6(d),CSCv7|5.1,CSF|PR.IP-1,ITSG-33|CM-6,LEVEL|1S,NESA|T3.2.1,PCI-DSSv3.1|2.2.4,PCI-DSSv3.2|2.2.4,SWIFT-CSCv1|2.3"
      see_also    : "https://workbench.cisecurity.org/files/2275"
# Note: Variable @NGINX_KEY@ replaced with "/etc/nginx/nginx.key" in field "file".
      file        : "/etc/nginx/nginx.key"
      mask        : "377"
      severity    : MEDIUM
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.4 Ensure only modern TLS protocols are used"
      info          : "Only modern TLS protocols should be enabled in NGINX for all client connections and upstream connections. Removing legacy TLS and SSL protocols (SSL 3.0, TLS 1.0 and 1.1), and enabling emerging and stable TLS protocols (TLS 1.2), ensures users are able to take advantage of strong security capabilities and protects them from insecure legacy protocols.

Rationale:

**Why disable SSL 3.0:**
The [POODLE Vulnerability](https://nvd.nist.gov/vuln/detail/CVE-2014-3566) allowed attackers to exploit SSL 3.0 to obtain cleartext information by exploiting weaknesses in CBC in 2014. SSL 3.0 is also no longer FIPS 140-2 compliant.

**Why disable TLS 1.0:**
TLS 1.0 was deprecated from use when PCI DSS Compliance mandated that it not be used for any applications processing credit card numbers in June 2018. TLS 1.0 does not make use of modern protections, and almost all user agents that do not support TLS 1.2 or higher are no longer supported by their vendor.

**Why disable TLS 1.1:**
Because of the increased security associated with higher versions of TLS, TLS 1.0 should be disabled. Modern browsers will begin to flag TLS 1.1 as deprecated in early 2019.

**Why enable TLS 1.2:**
TLS 1.2 takes advantage of several security features including modern cipher suites, perfect forward security, and authenticated encryption."
      solution      : "Run the following commands to change your ssl_protocols if they are already configured. This remediation advice assumes your nginx configuration file does not include server configuration outside of /etc/nginx/nginx.conf. You may have to also inspect the include files in your nginx.conf to ensure this is properly implemented.

**Web Server:**

sed -i 's/ssl_protocols[^;]*;/ssl_protocols TLSv1.2;/' /etc/nginx/nginx.conf

**Proxy:**

sed -i 's/proxy_ssl_protocols[^;]*;/proxy_ssl_protocols TLSv1.2;/' /etc/nginx/nginx.conf

If your ssl_protocols are not already configured, this can be accomplished manually by opening your web server or proxy server configuration file and manually adding the directives.

**Web Server:**

server {
 ssl_protocols TLSv1.2;
}

**Proxy:**

location / {
 proxy_pass cisecurity.org;
 proxy_ssl_protocols TLSv1.2;
 }"
      reference     : "800-171|3.1.13,800-53|AC-17(2),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.4.1(c),CSCv7|5.1,CSF|PR.AC-3,CSF|PR.PT-4,ITSG-33|AC-17(2),LEVEL|1S,NESA|T5.4.2,NIAv2|AM37,SWIFT-CSCv1|2.6"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*proxy_ssl_protocols[ ]*'"
      expect        : "^[\\s]*proxy_ssl_protocols[\\s]+TLSv1.2[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.5 Disable weak ciphers - proxy_ssl_ciphers"
      info          : "The ssl_ciphers directive should be used to configure the available ciphers on your web server, and the proxy_ssl_ciphers directive should be used to configure the available ciphers for your proxy. Weak ciphers should be disabled based on your company's policy or an industry best practice compliance profile.

The ssl_prefer_server_ciphers should be used to ensure the user agent respects the server's preferred cipher order and does not set its own. If you are using a proxy or load balancer, you should use the proxy_ssl_ciphers directive to ensure your upstream connections are negotiated using secure ciphers.

Rationale:

The use of strong ciphers is critical to maintaining strong encryption on your web server, load balancer, or proxy. Weak ciphers may compromise the security of your site or your users by allowing legacy user agents to connect to your site in a vulnerable way. You may also meet compliance concerns by ensuring that your upstream connections meet the same level of security if using a proxy or load balancer. The server should enforce the cipher preference on the server side to protect users from malicious actors on the client side."
      solution      : "The following procedures may be used to implement industry standard cipher profiles if you have an existing profile defined. These profiles may be modified to meet the requirements defined in your company's policy. This procedure assumes that all server blocks will be in /etc/nginx/nginx.conf and not inside any included files in the configuration.

Set the ssl_cipher directive as part of your server block, and set the proxy_ssl_ciphers directive as part of the location block for your upstream server.

This should look similar to the below examples:

**Server block configuration for client connectivity to web server, proxy, or load balancer:**

server {
 ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;
}

**Proxy or load balancer configuration for defined upstream negotiation:**

location / {
 proxy_pass https://cisecurity.org;
 proxy_ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;
}

The below procedure assumes the default configuration profile. If you do not have ssl_ciphers or proxy_ssl_ciphers defined, add the directives to your proxy or web server configuration profile, then run the below commands to configure them to your selected profile.

**FIPS 140-2 compliant proxy:**

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**FIPS 140-2 compliant web server:**

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;\nssl_prefer_server_ciphers on;
/' /etc/nginx/nginx.conf

**No weak ciphers SSLLABS proxy configuration**

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**No weak ciphers SSLLABS web server configuration:**

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**Mozilla modern profile proxy:**

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**Mozilla modern profile web server:**

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

For changes to take effect, you must recycle nginx:

service nginx restart"
      reference     : "800-171|3.1.13,800-53|AC-17(2),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.4.1(c),CSCv7|14.4,CSCv7|5.1,CSF|PR.AC-3,CSF|PR.PT-4,ITSG-33|AC-17(2),LEVEL|1S,NESA|T5.4.2,NIAv2|AM37,SWIFT-CSCv1|2.6"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*proxy_ssl_ciphers[ ]*'"
      expect        : "^[\\s]*proxy_ssl_ciphers[\\s]+ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.5 Disable weak ciphers - ssl_prefer_server_ciphers"
      info          : "The ssl_ciphers directive should be used to configure the available ciphers on your web server, and the proxy_ssl_ciphers directive should be used to configure the available ciphers for your proxy. Weak ciphers should be disabled based on your company's policy or an industry best practice compliance profile.

The ssl_prefer_server_ciphers should be used to ensure the user agent respects the server's preferred cipher order and does not set its own. If you are using a proxy or load balancer, you should use the proxy_ssl_ciphers directive to ensure your upstream connections are negotiated using secure ciphers.

Rationale:

The use of strong ciphers is critical to maintaining strong encryption on your web server, load balancer, or proxy. Weak ciphers may compromise the security of your site or your users by allowing legacy user agents to connect to your site in a vulnerable way. You may also meet compliance concerns by ensuring that your upstream connections meet the same level of security if using a proxy or load balancer. The server should enforce the cipher preference on the server side to protect users from malicious actors on the client side."
      solution      : "The following procedures may be used to implement industry standard cipher profiles if you have an existing profile defined. These profiles may be modified to meet the requirements defined in your company's policy. This procedure assumes that all server blocks will be in /etc/nginx/nginx.conf and not inside any included files in the configuration.

Set the ssl_cipher directive as part of your server block, and set the proxy_ssl_ciphers directive as part of the location block for your upstream server.

This should look similar to the below examples:

**Server block configuration for client connectivity to web server, proxy, or load balancer:**

server {
 ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;
}

**Proxy or load balancer configuration for defined upstream negotiation:**

location / {
 proxy_pass https://cisecurity.org;
 proxy_ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;
}

The below procedure assumes the default configuration profile. If you do not have ssl_ciphers or proxy_ssl_ciphers defined, add the directives to your proxy or web server configuration profile, then run the below commands to configure them to your selected profile.

**FIPS 140-2 compliant proxy:**

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**FIPS 140-2 compliant web server:**

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers ALL:!EXP:!NULL:!ADH:!LOW:!SSLv2:!SSLv3:!MD5:!RC4;\nssl_prefer_server_ciphers on;
/' /etc/nginx/nginx.conf

**No weak ciphers SSLLABS proxy configuration**

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**No weak ciphers SSLLABS web server configuration:**

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers HIGH:!aNULL:!CAMELLIA:!SHA:!RSA;\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**Mozilla modern profile proxy:**

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/proxy_ssl_ciphers[^;]*;/proxy_ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

**Mozilla modern profile web server:**

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';/' /etc/nginx/nginx.conf

Or if ssl_prefer_server_ciphers is not already enabled:

sed -i 's/ssl_ciphers[^;]*;/ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';\nssl_prefer_server_ciphers on;/' /etc/nginx/nginx.conf

For changes to take effect, you must recycle nginx:

service nginx restart"
      reference     : "800-171|3.1.13,800-53|AC-17(2),CN-L3|7.1.2.7(g),CN-L3|7.1.3.1(d),CN-L3|8.1.4.1(c),CSCv7|14.4,CSCv7|5.1,CSF|PR.AC-3,CSF|PR.PT-4,ITSG-33|AC-17(2),LEVEL|1S,NESA|T5.4.2,NIAv2|AM37,SWIFT-CSCv1|2.6"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*ssl_prefer_server_ciphers[ ]*'"
      expect        : "^[\\s]*ssl_prefer_server_ciphers[\\s]+on[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system      : "Linux"
      type        : CMD_EXEC
      description : "4.1.6 Ensure custom Diffie-Hellman parameters are used"
      info        : "Custom Diffie-Hellman (DH) key exchange parameters should be used. DH Ephemeral (DHE) parameters with at least 2048 bits should be generated.

Rationale:

Backward-compatible Perfect Forward Secrecy (PFS) ciphers (e.g. DHE-RSA-AES128-SHA256) should use strong and unique parameters. By default, NGINX will generate 1024-bit RSA keys for PFS ciphers; stronger alternatives should be used instead to provide better protection for data protected by encryption."
      solution    : "Generate strong DHE (Ephemeral Diffie-Hellman) parameters using the following commands:

mkdir /etc/nginx/ssl
openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048
chmod 400 /etc/nginx/ssl/dhparam.pem

Alter the server configuration to use the new parameters:

http {
 server {
 ssl_dhparam /etc/nginx/ssl/dhparam.pem;
 }
}"
      reference   : "800-171|3.13.11,800-53|SC-13,CSCv6|14.2,CSCv7|14.4,CSF|PR.DS-5,ISO/IEC-27001|A.10.1.1,ITSG-33|SC-13,LEVEL|1S,NESA|M5.2.6,NESA|T7.4.1,NIAv2|CY3,NIAv2|CY4,NIAv2|CY5b,NIAv2|CY5c,NIAv2|CY5d,NIAv2|CY7,NIAv2|NS5e"
      see_also    : "https://workbench.cisecurity.org/files/2275"
      cmd         : "nginx -T | grep '^[ ]*ssl_dhparam[ ]*'"
      expect      : "^[\\s]*ssl_dhparam"
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.7 Ensure Online Certificate Status Protocol (OCSP) stapling is enabled - ssl_stapling"
      info          : "OCSP allows a user's browser or another user agent to verify the certificate it is seeing is not revoked. OCSP stapling ensures your server presents this information to the user's browser in a way that best meets the performance and security needs of your website. It polls the Certificate Authority's (CA) OCSP server at regular intervals to ensure it is continuously kept up to date. OCSP stapling helps improve performance and security, so it should be enabled.

Rationale:

OCSP stapling protects your users from accessing a website where a private key is believed to be compromised. If a private key is compromised, an attacker may be able to obtain unauthorized access to the encrypted data transmitted by a user.

Note: OCSP stapling, while a step forward from the older certificate revocation list model, does share similar risks. Between the time a certificate is revoked and the point where a new signed OCSP profile is requested, if a server's certificate has been revoked a user agent may not be informed."
      solution      : "Follow this procedure to enable OCSP validation:

**Step 1:** Ensure your NGINX server has access to your CA's OCSP server.

Your CA's OCSP server may be found on your CA's website and will vary depending on your CA vendor. Issue the following command in order to check your connectivity to their site:

curl -I 'insert certificate authority ocsp server here'

If you get a 200 code response, your server has access.

**Step 2:** Enable OCSP on nginx.

Implement the ssl_stapling and ssl_stapling_verify directives. The directive ssl_stapling enables OCSP stapling, and the directive ssl_stapling_verify enables verification of the OCSP responses on nginx.

server {
 ssl_stapling on;
 ssl_stapling_verify on;
}"
      reference     : "800-53|SC-17,CSCv7|5.1,ITSG-33|SC-17,LEVEL|1S,NESA|T7.4.2,NIAv2|CY10,NIAv2|CY12,NIAv2|CY5a,NIAv2|SS25"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*ssl_stapling[ ]*'"
      expect        : "^[\\s]*ssl_stapling[\\s]+on[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.7 Ensure Online Certificate Status Protocol (OCSP) stapling is enabled - ssl_stapling_verify"
      info          : "OCSP allows a user's browser or another user agent to verify the certificate it is seeing is not revoked. OCSP stapling ensures your server presents this information to the user's browser in a way that best meets the performance and security needs of your website. It polls the Certificate Authority's (CA) OCSP server at regular intervals to ensure it is continuously kept up to date. OCSP stapling helps improve performance and security, so it should be enabled.

Rationale:

OCSP stapling protects your users from accessing a website where a private key is believed to be compromised. If a private key is compromised, an attacker may be able to obtain unauthorized access to the encrypted data transmitted by a user.

Note: OCSP stapling, while a step forward from the older certificate revocation list model, does share similar risks. Between the time a certificate is revoked and the point where a new signed OCSP profile is requested, if a server's certificate has been revoked a user agent may not be informed."
      solution      : "Follow this procedure to enable OCSP validation:

**Step 1:** Ensure your NGINX server has access to your CA's OCSP server.

Your CA's OCSP server may be found on your CA's website and will vary depending on your CA vendor. Issue the following command in order to check your connectivity to their site:

curl -I 'insert certificate authority ocsp server here'

If you get a 200 code response, your server has access.

**Step 2:** Enable OCSP on nginx.

Implement the ssl_stapling and ssl_stapling_verify directives. The directive ssl_stapling enables OCSP stapling, and the directive ssl_stapling_verify enables verification of the OCSP responses on nginx.

server {
 ssl_stapling on;
 ssl_stapling_verify on;
}"
      reference     : "800-53|SC-17,CSCv7|5.1,ITSG-33|SC-17,LEVEL|1S,NESA|T7.4.2,NIAv2|CY10,NIAv2|CY12,NIAv2|CY5a,NIAv2|SS25"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*ssl_stapling_verify[ ]*'"
      expect        : "^[\\s]*ssl_stapling_verify[\\s]+on[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.8 Ensure HTTP Strict Transport Security (HSTS) is enabled"
      info          : "HTTP Strict Transport Security (HSTS) headers instruct a user agent on how to communicate with a web server. HSTS headers ensure the strict transport security policies built into browsers and other user agents are informed only to communicate over HTTPS. HSTS with long validity periods should be used to most effectively secure your user population.

Strict-Transport-Security should have a long max-age, which is recommended to be at least six months in length. This ensures the browser remembers your website should only be accessible via HTTPS for this amount of time.

Rationale:

HSTS headers help protect a server's users from accessing the server over unencrypted protocols. This header helps to prevent HTTP downgrade attacks."
      solution      : "Ensure the below snippet of code can be found in your server configuration for your proxy or web server. This will ensure the HSTS header is set with a validity period of six months, or 15768000 seconds.

server {
 add_header Strict-Transport-Security 'max-age=15768000;';
}"
      reference     : "800-171|3.1.11,800-53|AC-12,CN-L3|7.1.2.2(d),CN-L3|7.1.3.7(b),CN-L3|8.1.4.1(b),CSCv7|14.4,CSCv7|5.1,ITSG-33|AC-12,LEVEL|1S,NIAv2|NS49"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '[ ]*Strict-Transport-Security[ ]*'"
      expect        : "^[\\s]*add_header[\\s]+Strict-Transport-Security[\\s]+[\"']max-age=(1576[8-9][0-9]{3}|157[6-9][0-9]{4}|15[7-9][0-9]{5}|1[5-9][0-9]{6}|[2-9][0-9]{7,});[\"']"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.10 Ensure upstream server traffic is authenticated with a client certificate - proxy_ssl_certificate"
      info          : "Client certificate validation allows the upstream server to authenticate the identity of the client connecting to it. This assists in the establishment of mutual authentication between the client and the server.

Rationale:

Using client certificate validation allows you to establish a trusted proxy server."
      solution      : "In order to implement this recommendation, you must create a client certificate to be authenticated against and have it signed. Once you have a signed certificate, place the certificate in a location of your choice. In the below example, we use /etc/nginx/ssl/cert.pem. Implement the configuration as part of the location block:

proxy_ssl_certificate /etc/nginx/ssl/nginx.pem;
proxy_ssl_certificate_key /etc/nginx/ssl/nginx.key;"
      reference     : "800-53|SC-17,CSCv6|1.6,CSCv7|1.8,ITSG-33|SC-17,LEVEL|1S,NESA|T7.4.2,NIAv2|CY10,NIAv2|CY12,NIAv2|CY5a,NIAv2|SS25"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*proxy_ssl_certificate[ ]*'"
      expect        : "^[\\s]*proxy_ssl_certificate[\\s]+/etc/nginx/ssl/nginx.pem[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "4.1.10 Ensure upstream server traffic is authenticated with a client certificate - proxy_ssl_certificate_key"
      info          : "Client certificate validation allows the upstream server to authenticate the identity of the client connecting to it. This assists in the establishment of mutual authentication between the client and the server.

Rationale:

Using client certificate validation allows you to establish a trusted proxy server."
      solution      : "In order to implement this recommendation, you must create a client certificate to be authenticated against and have it signed. Once you have a signed certificate, place the certificate in a location of your choice. In the below example, we use /etc/nginx/ssl/cert.pem. Implement the configuration as part of the location block:

proxy_ssl_certificate /etc/nginx/ssl/nginx.pem;
proxy_ssl_certificate_key /etc/nginx/ssl/nginx.key;"
      reference     : "800-53|SC-17,CSCv6|1.6,CSCv7|1.8,ITSG-33|SC-17,LEVEL|1S,NESA|T7.4.2,NIAv2|CY10,NIAv2|CY12,NIAv2|CY5a,NIAv2|SS25"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*proxy_ssl_certificate_key[ ]*'"
      expect        : "^[\\s]*proxy_ssl_certificate_key[\\s]+/etc/nginx/ssl/nginx.key[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <report type:"WARNING">
      description : "5.1.2 Ensure only whitelisted HTTP methods are allowed"
      info        : "HTTP methods (also known as verbs) allow different actions to be requested from the web server at a specified path. Only the necessary methods should be enabled.

Rationale:

Most websites only require the methods GET, POST and HEAD to function correctly. Web applications may also require other verbs (e.g. DELETE). In order to narrow vectors of attack, it is recommended to only enable the required verbs.

NOTE: Nessus has not performed this check. Please review the benchmark to ensure target compliance."
      solution    : "To remove unneeded methods and only allow required methods, add the following into a server or location block in your nginx.conf. The below snippet assumes only the methods GET, HEAD and POST are required for an application. The reason for 444 as a response is because it contains no information and can help mitigate automated attacks.

if ($request_method !~ ^(GET|HEAD|POST)$) {
 return 444;
}"
      reference   : "CSCv7|5.1,LEVEL|1NS"
      see_also    : "https://workbench.cisecurity.org/files/2275"
    </report>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "5.2.1 Ensure timeout values for reading the client header and body are set correctly - client_body_timeout"
      info          : "The client_header_timeout and client_body_timeout directives define the time the server will wait for the header or body to be sent from the client. If the client does not send the entire header in this predefined timeframe, the server will send back a 408 request timeout error.

Rationale:

Setting the client header and body timeouts help your server mitigate possible denial of service attacks. By timing out a request, the server is able to free up resources that may be waiting for the body or header."
      solution      : "Find the HTTP or server block of your nginx configuration and add the client_header_timeout and client_body_timeout directives set to the configuration. The below example sets the timeouts to 10 seconds.

client_body_timeout 10;
client_header_timeout 10;"
      reference     : "800-171|3.1.11,800-53|AC-12,CN-L3|7.1.2.2(d),CN-L3|7.1.3.7(b),CN-L3|8.1.4.1(b),CSCv7|5.1,ITSG-33|AC-12,LEVEL|1S,NIAv2|NS49"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*client_body_timeout[ ]*'"
      expect        : "^[\\s]*client_body_timeout[\\s]+([0-9]|10)[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "5.2.1 Ensure timeout values for reading the client header and body are set correctly - client_header_timeout"
      info          : "The client_header_timeout and client_body_timeout directives define the time the server will wait for the header or body to be sent from the client. If the client does not send the entire header in this predefined timeframe, the server will send back a 408 request timeout error.

Rationale:

Setting the client header and body timeouts help your server mitigate possible denial of service attacks. By timing out a request, the server is able to free up resources that may be waiting for the body or header."
      solution      : "Find the HTTP or server block of your nginx configuration and add the client_header_timeout and client_body_timeout directives set to the configuration. The below example sets the timeouts to 10 seconds.

client_body_timeout 10;
client_header_timeout 10;"
      reference     : "800-171|3.1.11,800-53|AC-12,CN-L3|7.1.2.2(d),CN-L3|7.1.3.7(b),CN-L3|8.1.4.1(b),CSCv7|5.1,ITSG-33|AC-12,LEVEL|1S,NIAv2|NS49"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*client_header_timeout[ ]*'"
      expect        : "^[\\s]*client_header_timeout[\\s]+([0-9]|10)[\\s]*;"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "5.2.2 Ensure the maximum request body size is set correctly"
      info          : "The client_max_body_size directive sets the size of the request body that is allowed to read a client request. This defines the number of bytes allowed in a request and is equivalent to the Content-Length request header field.

Rationale:

Limiting the size of the request body helps prevent unexpectedly long or large client requests from being passed to an application to perform buffer overflow attacks. This value should be set low enough to protect the application but high enough not to interfere with functionality and block legitimate request bodies."
      solution      : "Find the HTTP or server block of your nginx configuration and add the client_max_body_size set to 100K in this block. The appropriate value may be different based on your application's needs.

client_max_body_size 100K"
      reference     : "800-53|SC-5,CSCv7|5.1,CSF|DE.CM-1,CSF|PR.DS-4,ITSG-33|SC-5,LEVEL|1S,NESA|T3.3.1,NIAv2|GS10c,NIAv2|GS8e"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*client_max_body_size[ ]*'"
# Note: Variable @CLIENT_MAX_BODY_SIZE@ replaced with "100K" in field "expect".
      expect        : "^[\\s]*client_max_body_size[\\s]+100K"
      dont_echo_cmd : YES
    </custom_item>

    <custom_item>
      system        : "Linux"
      type          : CMD_EXEC
      description   : "5.2.3 Ensure the maximum buffer size for URIs is defined"
      info          : "The large_client_header_buffers directive defines the number and size of buffers used within the URI. A request cannot exceed the size of this buffer when this directive is configured. The large_client_header_buffers directive should be set to restrict buffer usage. The number of buffers should generally set to two and the length be set to 1K; however, this may not be a good fit for your application and may need to be set differently.

Rationale:

The large_client_header_buffers directive may assist in preventing buffer overflow attacks that leverage long URI query parameters."
      solution      : "Open your nginx.conf file and locate your server or HTTP blocks. This may be added to the HTTP block for all configurations or the server block for more specific configurations to meet your needs. Add the below line to implement this recommendation:

large_client_header_buffers 2 1k"
      reference     : "800-53|SC-5,CSCv7|5.1,CSF|DE.CM-1,CSF|PR.DS-4,ITSG-33|SC-5,LEVEL|1S,NESA|T3.3.1,NIAv2|GS10c,NIAv2|GS8e"
      see_also      : "https://workbench.cisecurity.org/files/2275"
      cmd           : "nginx -T | grep '^[ ]*large_client_header_buffers[ ]*'"
# Note: Variable @LARGE_CLIENT_HEADER_BUFFERS@ replaced with "2 1k" in field "expect".
      expect        : "^[\\s]*large_client_header_buffers[\\s]+2 1k"
      dont_echo_cmd : YES
    </custom_item>
  </then>
</if>

</check_type>
