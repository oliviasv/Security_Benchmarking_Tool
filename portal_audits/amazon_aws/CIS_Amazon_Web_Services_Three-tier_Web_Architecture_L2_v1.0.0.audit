#
# This script is Copyright (C) 2004-2020 and is owned by Tenable, Inc. or an Affiliate thereof.
#
# This script is released under the Tenable Subscription License and
# may not be used from within scripts released under another license
# without authorization from Tenable, Inc.
#
# See the following licenses for details:
#
# http://static.tenable.com/prod_docs/Nessus_6_SLA_and_Subscription_Agreement.pdf
#
# @PROFESSIONALFEED@
# $Revision: 1.4 $
# $Date: 2020/04/14 $
#
# description : This .audit is designed against the CIS Amazon Web Services Three-tier Web Architecture Benchmark Version 1.0.0.
#
# Ref         : https://workbench.cisecurity.org/files/260
#
#<ui_metadata>
#<display_name>CIS Amazon Web Services Three-tier Web Architecture L2 1.0.0</display_name>
#<spec>
#  <type>CIS</type>
#  <name>CIS Amazon Web Services Three-teir Web Architecture L2</name>
#  <version>1.0.0</version>
#</spec>
#<labels>amazon_aws,amazon,aws,security,cis</labels>
#<benchmark_refs>LEVEL,CSCv6,CCE</benchmark_refs>
#<variables>
#  <variable>
#    <name>WEB_TIER_KMS_ALIAS</name>
#    <default>WEB_TIER_KMS_ALIAS</default>
#    <description>Web-tier KMS Alias Name</description>
#    <info>Web-tier KMS Alias Name</info>
#  </variable>
#  <variable>
#    <name>APP_TIER_KMS_ALIAS</name>
#    <default>APP_TIER_KMS_ALIAS</default>
#    <description>App-tier KMS Alias Name</description>
#    <info>App-tier KMS Alias Name</info>
#  </variable>
#  <variable>
#    <name>DATA_TIER_KMS_ALIAS</name>
#    <default>DATA_TIER_KMS_ALIAS</default>
#    <description>Data-tier KMS Alias Name</description>
#    <info>Data-tier KMS Alias Name</info>
#  </variable>
#  <variable>
#    <name>WEB_TIER_ELB</name>
#    <default>WEB_TIER_ELB</default>
#    <description>Designated Load Balancer Name for your Web-tier environment.</description>
#    <info>Web-tier Load Balancer Name</info>
#  </variable>
#  <variable>
#    <name>APP_TIER_ELB</name>
#    <default>APP_TIER_ELB</default>
#    <description>Designated Load Balancer Name for your App-tier environment.</description>
#    <info>APP-tier Load Balancer Name</info>
#  </variable>
#  <variable>
#    <name>HOSTED_ZONE_ID</name>
#    <default>HOSTED_ZONE_ID</default>
#    <description>The Hosted Zone ID used by the application.</description>
#    <info>Hosted Zone ID for application</info>
#  </variable>
#  <variable>
#    <name>DB_INSTANCE_IDENTIFIER</name>
#    <default>DB_INSTANCE_IDENTIFIER</default>
#    <description>The DB Instance Identifier for your application DB instance.</description>
#    <info>DB Instance Identifier</info>
#  </variable>
#</variables>
#</ui_metadata>

<check_type:"amazon_aws">

<custom_item>
  type           : KMS
  description    : "1.1 Ensure a customer created Customer Master Key (CMK) is created for the Web-tier"
  info           : "AWS Key Management Service (KMS) by default provides service Customer Managed Keys (CMK). Customers also have the ability to create CMKs, which allows for configuration of key rotation and key policy which is applied to the customer created CMK.

  You can use the key policy by itself to control who has access to the CMK and what actions each identity can perform. Controlling access this way specifies the full scope of access to the CMK in a single document (the key policy).

  Customer created CMKs can be used for:

* AWS Service level encryption(e.g. EBS, RDS, S3)
* Key management for file/application level encryption
Ensures principle of least privilege on key ownership & usage"
  solution       : "Using the Amazon unified command line interface:

* If there is no alias listed for Web tier, create new KMS key and note the \"KeyId\" element:

  aws kms create-key

* Create an alias for the Web tier key using the above KeyId:

  aws kms create-alias --alias-name _<web_tier_kms_alias>_ --target-key-id _<web_tier_kms_key>_"
  reference      : "800-53|AC-1,CN-L3|8.1.10.6(c),CN-L3|8.1.4.2(e),CSF|ID.GV-1,CSF|ID.GV-3,ISO/IEC-27001|A.9.1.1,ITSG-33|AC-1,LEVEL|2S,NESA|M1.2.2,NIAv2|AM29,NIAv2|AM30"
  see_also       : "https://workbench.cisecurity.org/files/260"
  aws_action     : "ListAliases"
  regex          : "alias/"
# Note: Variable @WEB_TIER_KMS_ALIAS@ replaced with "WEB_TIER_KMS_ALIAS" in field "expect".
  expect         : "alias/WEB_TIER_KMS_ALIAS"
  json_transform : '.[]|.Aliases[]|.AliasName'
</custom_item>

<custom_item>
  type           : KMS
  description    : "1.2 Ensure a customer created Customer Master Key (CMK) is created for the App-tier"
  info           : "AWS Key Management Service (KMS) by default provides service Customer Managed Keys (CMK). Customers also have the ability to create CMKs, which allows for configuration of key rotation and key policy which is applied to the customer created CMK.

  You can use the key policy by itself to control who has access to the CMK and what actions each identity can perform. Controlling access this way specifies the full scope of access to the CMK in a single document (the key policy).

  Customer created CMKs can be used for:

* AWS Service level encryption(e.g. EBS, RDS, S3)
* Key management for file/application level encryption
Ensures principle of least privilege on key ownership & usage"
  solution       : "Using the Amazon unified command line interface:

* If there is no alias listed for App tier, create new KMS key and note the \"KeyId\" element:

  aws kms create-key

* Create an alias for the App tier key using the above KeyId:

  aws kms create-alias --alias-name _<app_tier_kms_alias>_ --target-key-id _<app_tier_kms_key>_"
  reference      : "800-53|AC-1,CN-L3|8.1.10.6(c),CN-L3|8.1.4.2(e),CSF|ID.GV-1,CSF|ID.GV-3,ISO/IEC-27001|A.9.1.1,ITSG-33|AC-1,LEVEL|2S,NESA|M1.2.2,NIAv2|AM29,NIAv2|AM30"
  see_also       : "https://workbench.cisecurity.org/files/260"
  aws_action     : "ListAliases"
  regex          : "alias/"
# Note: Variable @APP_TIER_KMS_ALIAS@ replaced with "APP_TIER_KMS_ALIAS" in field "expect".
  expect         : "alias/APP_TIER_KMS_ALIAS"
  json_transform : '.[]|.Aliases[]|.AliasName'
</custom_item>

<custom_item>
  type           : KMS
  description    : "1.3 Ensure a customer created Customer Master Key (CMK) is created for the Database-Tier"
  info           : "AWS Key Management Service (KMS) by default provides service Customer Managed Keys (CMK). Customers also have the ability to create CMKs, which allows for configuration of key rotation and key policy which is applied to the customer created CMK.

  You can use the key policy by itself to control who has access to the CMK and what actions each identity can perform. Controlling access this way specifies the full scope of access to the CMK in a single document (the key policy).

  Customer created CMKs can be used for:

* AWS Service level encryption(e.g. EBS, RDS, S3)
* Key management for file/application level encryption
Ensures principle of least privilege on key ownership & usage"
  solution       : "Using the Amazon unified command line interface:

* If there is no alias listed for Data tier, create new KMS key and note the \"KeyId\" element:

  aws kms create-key

* Create an alias for the Data tier key using the above KeyId:

  aws kms create-alias --alias-name _<data_tier_kms_alias>_ --target-key-id <_data_tier_kms_key>_"
  reference      : "800-53|AC-1,CN-L3|8.1.10.6(c),CN-L3|8.1.4.2(e),CSF|ID.GV-1,CSF|ID.GV-3,ISO/IEC-27001|A.9.1.1,ITSG-33|AC-1,LEVEL|2S,NESA|M1.2.2,NIAv2|AM29,NIAv2|AM30"
  see_also       : "https://workbench.cisecurity.org/files/260"
  aws_action     : "ListAliases"
  regex          : "alias/"
# Note: Variable @DATA_TIER_KMS_ALIAS@ replaced with "DATA_TIER_KMS_ALIAS" in field "expect".
  expect         : "alias/DATA_TIER_KMS_ALIAS"
  json_transform : '.[]|.Aliases[]|.AliasName'
</custom_item>

<custom_item>
  type        : ELB
  description : "1.11 Ensure Web Tier ELB is using HTTPS listener"
  info        : "A load balancer takes requests from clients and distributes them across the EC2 instances that are registered with the load balancer (also known as back-end instances).

  A listener is a process that checks for connection requests. It is configured with a protocol and a port for front-end (client to load balancer) connections

* Note: an HTTPS listener configured on the ELB is not mandatory if you are terminating SSL connections directly on the Web Tier EC2 instances, and using a TCP listener on the ELB (TCP pass-through)
Using an HTTPS Elastic Load Balancer listener will make sure the application traffic between the client and the Web Tier ELB is encrypted over the SSL\TLS channel."
  solution    : "Using the Amazon unified command line interface:

* If the ListenerDescription field is missing, add a new HTTPS listener configured with a SSL\TLS certificate (the listener forwards traffic to the backend instances on port 80, but this can be modified by editing InstancePort=80):

  aws elb create-load-balancer-listeners --load-balancer-name <web_tier_elb> --listeners Protocol=HTTPS,LoadBalancerPort=443,InstanceProtocol=HTTP,InstancePort=80, SSLCertificateId=<ssl_certificate_arn>"
  reference   : "800-53|IA-3(1),CSF|PR.AC-1,ITSG-33|IA-3(1),LEVEL|2S,NESA|T5.4.3"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "DescribeLoadBalancers"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
# Note: Variable @WEB_TIER_ELB@ replaced with "WEB_TIER_ELB" in field "xsl_stmt".
  xsl_stmt    : "<xsl:when test=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'WEB_TIER_ELB']\">"
# Note: Variable @WEB_TIER_ELB@ replaced with "WEB_TIER_ELB" in field "xsl_stmt".
  xsl_stmt    : "<xsl:for-each select=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'WEB_TIER_ELB']/elb:ListenerDescriptions/elb:member/elb:Listener\">"
  xsl_stmt    : "<xsl:text>Protocol = </xsl:text><xsl:value-of select=\"elb:Protocol\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Protocol = Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : "Protocol ="
  expect      : "Protocol = (HTTPS|TCP)"
</custom_item>

<if>
  <condition type:"AND">
    <custom_item>
      type        : ELB
      description : "Describe Load Balancers - TCP pass-through"
      aws_action  : "DescribeLoadBalancers"
      xsl_stmt    : "<xsl:template match=\"/\">"
      xsl_stmt    : "<xsl:choose>"
# Note: Variable @WEB_TIER_ELB@ replaced with "WEB_TIER_ELB" in field "xsl_stmt".
      xsl_stmt    : "<xsl:when test=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'WEB_TIER_ELB']\">"
# Note: Variable @WEB_TIER_ELB@ replaced with "WEB_TIER_ELB" in field "xsl_stmt".
      xsl_stmt    : "<xsl:for-each select=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'WEB_TIER_ELB']/elb:ListenerDescriptions/elb:member/elb:Listener\">"
      xsl_stmt    : "<xsl:text>Protocol = </xsl:text><xsl:value-of select=\"elb:Protocol\"/><xsl:text>&#10;</xsl:text>"
      xsl_stmt    : "</xsl:for-each>"
      xsl_stmt    : "</xsl:when>"
      xsl_stmt    : "<xsl:otherwise>"
      xsl_stmt    : "<xsl:text>Protocol Not Found</xsl:text>"
      xsl_stmt    : "</xsl:otherwise>"
      xsl_stmt    : "</xsl:choose>"
      xsl_stmt    : "</xsl:template>"
      regex       : "Protocol ="
      expect      : "Protocol = TCP"
    </custom_item>
  </condition>

  <then>
    <report type:"PASSED">
      description : "1.12 Ensure App Tier ELB have SSL\TLS Certificate attached"
      info        : "When you use HTTPS for your front-end listener, you must deploy an SSL/TLS certificate on your load balancer. The load balancer uses the certificate to terminate the connection and then decrypt requests from clients before sending them to the back-end instances.

  The SSL\TLS protocol uses an X.509 certificate (SSL\TLS server certificate) to authenticate both the client and the back-end application. An X.509 certificate is a digital form of identification issued by a trusted certificate authority (CA) and contains identification information, a validity period, a public key, a serial number, and the digital signature of the issuer.

  You can create a certificate using a Third Party Certificate Authority, AWS Certificate Manager or a self signed certificate like OpenSSL.

* Note: an SSL certificate configured on the ELB is not mandatory if you are terminating SSL connections directly on the App Tier EC2 instances, and using a TCP listener on the ELB (TCP pass-through)
All the application traffic between the Web Tier instances and the App Tier ELB nodes should be encrypted using an SSL\TLS certificate."
      solution    : "Using the Amazon unified command line interface:

* Adding a HTTPS listener configured with a SSL\TLS certificate (the listener forwards traffic to the backend instances on port 80, but this can be modified by editing InstancePort=80):

  aws elb create-load-balancer-listeners --load-balancer-name <app_tier_elb> --listeners Protocol=HTTPS,LoadBalancerPort=443,InstanceProtocol=HTTP,InstancePort=80, SSLCertificateId=<ssl_certificate_arn>"
      reference   : "LEVEL|2S"
      see_also    : "https://workbench.cisecurity.org/files/260"
    </report>
  </then>

  <else>
    <custom_item>
      type        : ELB
      description : "1.12 Ensure App Tier ELB have SSL\TLS Certificate attached"
      info        : "When you use HTTPS for your front-end listener, you must deploy an SSL/TLS certificate on your load balancer. The load balancer uses the certificate to terminate the connection and then decrypt requests from clients before sending them to the back-end instances.

  The SSL\TLS protocol uses an X.509 certificate (SSL\TLS server certificate) to authenticate both the client and the back-end application. An X.509 certificate is a digital form of identification issued by a trusted certificate authority (CA) and contains identification information, a validity period, a public key, a serial number, and the digital signature of the issuer.

  You can create a certificate using a Third Party Certificate Authority, AWS Certificate Manager or a self signed certificate like OpenSSL.

* Note: an SSL certificate configured on the ELB is not mandatory if you are terminating SSL connections directly on the App Tier EC2 instances, and using a TCP listener on the ELB (TCP pass-through)
All the application traffic between the Web Tier instances and the App Tier ELB nodes should be encrypted using an SSL\TLS certificate."
      solution    : "Using the Amazon unified command line interface:

* Adding a HTTPS listener configured with a SSL\TLS certificate (the listener forwards traffic to the backend instances on port 80, but this can be modified by editing InstancePort=80):

  aws elb create-load-balancer-listeners --load-balancer-name <app_tier_elb> --listeners Protocol=HTTPS,LoadBalancerPort=443,InstanceProtocol=HTTP,InstancePort=80, SSLCertificateId=<ssl_certificate_arn>"
      reference   : "800-171|3.13.11,800-53|SC-13,CSF|PR.DS-5,ISO/IEC-27001|A.10.1.1,ITSG-33|SC-13,LEVEL|2S,NESA|M5.2.6,NESA|T7.4.1,NIAv2|CY3,NIAv2|CY4,NIAv2|CY5b,NIAv2|CY5c,NIAv2|CY5d,NIAv2|CY7,NIAv2|NS5e"
      see_also    : "https://workbench.cisecurity.org/files/260"
      aws_action  : "DescribeLoadBalancers"
      xsl_stmt    : "<xsl:template match=\"/\">"
      xsl_stmt    : "<xsl:choose>"
# Note: Variable @WEB_TIER_ELB@ replaced with "WEB_TIER_ELB" in field "xsl_stmt".
      xsl_stmt    : "<xsl:when test=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'WEB_TIER_ELB']\">"
# Note: Variable @WEB_TIER_ELB@ replaced with "WEB_TIER_ELB" in field "xsl_stmt".
      xsl_stmt    : "<xsl:for-each select=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'WEB_TIER_ELB']/elb:ListenerDescriptions/elb:member/elb:Listener\">"
      xsl_stmt    : "<xsl:text>SSL Certificate ID = </xsl:text><xsl:value-of select=\"elb:SSLCertificateId\"/><xsl:text>&#10;</xsl:text>"
      xsl_stmt    : "</xsl:for-each>"
      xsl_stmt    : "</xsl:when>"
      xsl_stmt    : "<xsl:otherwise>"
      xsl_stmt    : "<xsl:text>SSL Certificate ID Not Found</xsl:text>"
      xsl_stmt    : "</xsl:otherwise>"
      xsl_stmt    : "</xsl:choose>"
      xsl_stmt    : "</xsl:template>"
      regex       : "SSL Certificate ID ="
      expect      : "SSL Certificate ID = .*"
    </custom_item>
  </else>
</if>

<custom_item>
  type        : ELB
  description : "1.13 Ensure App Tier ELB have the latest SSL Security Policies configured"
  info        : "Elastic Load Balancing uses an Secure Socket Layer (SSL) negotiation configuration, known as a security policy, to negotiate SSL/TLS connections between a client and the load balancer. A security policy is a combination of SSL/TLS protocols, ciphers, and the Server Order Preference option.

  Elastic Load Balancing supports configuring your load balancer to use either predefined or custom security policies.

  Secure Sockets Layer (SSL) and Transport Layer Security (TLS) are cryptographic protocols that are used to encrypt confidential data over insecure networks such as the Internet. The TLS protocol is a newer version of the SSL protocol. In the Elastic Load Balancing documentation, we refer to both SSL and TLS protocols as the SSL protocol.

* Note: an SSL certificate configured on the ELB and an SSL Security Policy is not mandatory if you are terminating SSL connections directly on the App Tier EC2 instances, and using a TCP listener on the ELB (TCP pass-through)
Making sure the latest ELB SSL Security Policy is used will ensure the SSL/TLS connection will be negotiated using only the appropriate cryptographic protocols deemed safe with no proven vulnerabilities."
  solution    : "Using the Amazon unified command line interface:

  (Note that you should replace <app_tier_elb> with your App-tier ELB name, and _<latest_ssl_policy>_ with the proper policy name)

  aws elb set-load-balancer-policies-of-listener --load-balancer-name <app_tier_elb> --load-balancer-port 443 --policy-names _<latest_ssl_policy>_"
  reference   : "800-53|SC-17,ITSG-33|SC-17,LEVEL|2S,NESA|T7.4.2,NIAv2|CY10,NIAv2|CY12,NIAv2|CY5a,NIAv2|SS25"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "DescribeLoadBalancers"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
# Note: Variable @APP_TIER_ELB@ replaced with "APP_TIER_ELB" in field "xsl_stmt".
  xsl_stmt    : "<xsl:when test=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'APP_TIER_ELB']\">"
# Note: Variable @APP_TIER_ELB@ replaced with "APP_TIER_ELB" in field "xsl_stmt".
  xsl_stmt    : "<xsl:for-each select=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'APP_TIER_ELB']/elb:ListenerDescriptions/elb:member/elb:PolicyNames\">"
  xsl_stmt    : "<xsl:text>Policy Name = </xsl:text><xsl:value-of select=\"elb:member\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Policy Name Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : "Policy Name ="
  expect      : "Policy Name = .*"
</custom_item>

<custom_item>
  type        : ELB
  description : "1.14 Ensure App Tier ELB is using HTTPS listener"
  info        : "A load balancer takes requests from clients and distributes them across the EC2 instances that are registered with the load balancer (also known as back-end instances).

  A listener is a process that checks for connection requests. It is configured with a protocol and a port for front-end (client to load balancer) connections.

* Note: an HTTPS listener configured on the ELB is not mandatory if you are terminating SSL connections directly on the App Tier EC2 instances, and using a TCP listener on the ELB (TCP pass-through)
Using an HTTPS Elastic Load Balancer listener will make sure the application traffic between the client and the App Tier ELB is encrypted over the SSL\TLS channel."
  solution    : "Using the Amazon unified command line interface:

* If the ListenerDescription field is missing, add a new HTTPS listener configured with a SSL\TLS certificate (the listener forwards traffic to the backend instances on port 80, but this can be modified by editing InstancePort=80):

  aws elb create-load-balancer-listeners --load-balancer-name <app_tier_elb> --listeners Protocol=HTTPS,LoadBalancerPort=443,InstanceProtocol=HTTP,InstancePort=80, SSLCertificateId=<ssl_certificate_arn>"
  reference   : "800-53|IA-3(1),CSF|PR.AC-1,ITSG-33|IA-3(1),LEVEL|2S,NESA|T5.4.3"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "DescribeLoadBalancers"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
# Note: Variable @APP_TIER_ELB@ replaced with "APP_TIER_ELB" in field "xsl_stmt".
  xsl_stmt    : "<xsl:when test=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'APP_TIER_ELB']\">"
# Note: Variable @APP_TIER_ELB@ replaced with "APP_TIER_ELB" in field "xsl_stmt".
  xsl_stmt    : "<xsl:for-each select=\"//elb:LoadBalancerDescriptions/elb:member[elb:LoadBalancerName = 'APP_TIER_ELB']/elb:ListenerDescriptions/elb:member/elb:Listener\">"
  xsl_stmt    : "<xsl:text>Protocol = </xsl:text><xsl:value-of select=\"elb:Protocol\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Protocol = Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : "Protocol ="
  expect      : "Protocol = (HTTPS|TCP)"
</custom_item>

<custom_item>
  type        : IAM
  description : "1.15 Ensure all Public Web Tier SSL\TLS certificates are >30 days from Expiration"
  info        : "Public SSL\TLS certificates that are used for AWS resources such as the ELB or CloudFront should always be renewed prior to expiration both as a security best practice and to ensure the reputation of the web application is not impacted by an expired certificate.
SSL\TLS certificates that are public should be renewed prior to expiration.

NOTE: Nessus has provided the target output to assist in reviewing the benchmark to ensure target compliance."
  solution    : "Using the Amazon unified command line interface:

* Request a certificate renewal from your CA, and upload the new certificate in IAM:

  aws iam upload-server-certificate --server-certificate-name _<ssl_certificate_name>_ --certificate-body file://public_key_cert_file.pem --private-key file://my_private_key.pem --certificate-chain file://my_certificate_chain_file.pem



* For Amazon Certificate Manager users the renewal is managed by ACM service"
  reference   : "800-171|3.14.6,800-171|3.14.7,800-53|SI-4,CN-L3|7.1.3.5(a),CN-L3|8.1.10.5(b),CN-L3|8.1.10.6(f),CSF|DE.AE-1,CSF|DE.AE-2,CSF|DE.AE-3,CSF|DE.AE-4,CSF|DE.CM-1,CSF|DE.CM-5,CSF|DE.CM-6,CSF|DE.CM-7,CSF|DE.DP-2,CSF|DE.DP-3,CSF|DE.DP-4,CSF|DE.DP-5,CSF|ID.RA-1,CSF|PR.DS-5,CSF|PR.IP-8,CSF|RS.AN-1,CSF|RS.CO-3,ITSG-33|SI-4,LEVEL|2S,NESA|M1.2.2"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "ListServerCertificates"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//iam:ServerCertificateMetadataList/iam:member\">"
  xsl_stmt    : "<xsl:for-each select=\"//iam:ServerCertificateMetadataList/iam:member\">"
  xsl_stmt    : "<xsl:value-of select=\"iam:ServerCertificateName\"/><xsl:text> : Expiration Date = </xsl:text><xsl:value-of select=\"iam:Expiration\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>No Expiration Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  not_expect  : ".* : Expiration Date ="
  severity    : MEDIUM
</custom_item>

<custom_item>
  type        : CLOUDFRONT
  description : "1.17 Ensure CloudFront to Origin connection is configured using TLS1.1+ as the SSL\TLS protocol"
  info        : "CloudFront can connect to your origin using only HTTP, only HTTPS, or to connect by matching the protocol used by the viewer. Our recommendation is to use HTTPS only. In this case you can choose which SSL\TLS protocols CloudFront is allowed to use when establishing an HTTPS connection to your origin. Ensure that you are using only TLS1.1+ as the SSL\TLS protocol.
It used to be believed that TLS v1 was marginally more secure than SSL v3.0, its predecessor. However, developments, such as the POODLE vulnerability have shown that SSL v3.0 is now insecure.

  Subsequent versions of TLS -- v1.1 and v1.2 are significantly more secure and fix many vulnerabilities present in SSL v3.0 and TLS v1. For example, the BEAST attack that can completely break web sites running on older SSL v3.0 and TLS v1 protocols. The newer TLS versions, if properly configured, prevent the BEAST and other attack vectors and provide many stronger ciphers and encryption methods."
  solution    : "Using the Amazon unified command line interface:

* For configuring Origin SSL protocols first save locally the current distribution config:

  aws cloudfront get-distribution-config --id <application_cfn_distribution_id> --query \"DistributionConfig\" > /tmp/cf-distribution.json

* Edit and replace \"OriginSslProtocols\" element in /tmp/cf-distribution.json with the below section:

  \"OriginSslProtocols\": {
 \"Items\": [
 \"TLSv1.1\",
 \"TLSv1.2\"
 ],
 \"Quantity\": 2
},

* Retrieve the current ETag of your CloudFront distribution:

  aws cloudfront get-distribution-config --id <application_cfn_distribution_id> --query \"ETag\"

* Update the CloudFront distribution using the edited config and the above Etag:

  aws cloudfront update-distribution --id <application_cfn_distribution_id> --distribution-config file:///tmp/cf-distribution.json --if-match <application_cfn_distribution_etag>"
  reference   : "800-171|3.13.8,800-53|SC-8(1),CSF|PR.DS-2,CSF|PR.DS-5,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|SC-8(1),LEVEL|2S,NESA|T7.4.1,NIAv2|NS5d,NIAv2|NS6b,SWIFT-CSCv1|2.1,TBA-FIISB|29.1"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "ListDistributions"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//cloudfront:Items\">"
  xsl_stmt    : "<xsl:for-each select=\"//cloudfront:Items/cloudfront:DistributionSummary\">"
  xsl_stmt    : "<xsl:value-of select=\"cloudfront:Id\"/><xsl:text> : Origin Ssl Protocols = </xsl:text><xsl:value-of select=\"cloudfront:Origins/cloudfront:Items/cloudfront:Origin/cloudfront:CustomOriginConfig/cloudfront:OriginSslProtocols/cloudfront:Items\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Origin Ssl Protocols = Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : ".* : Origin Ssl Protocols ="
  expect      : ".* : Origin Ssl Protocols = (TLSv1\.(1|2)){1,2}"
</custom_item>

<custom_item>
  type        : CLOUDFRONT
  description : "3.12 Configure HTTP to HTTPS Redirects with a CloudFront Viewer Protocol Policy"
  info        : "Configure the Viewer Protocol Policy for your CloudFront cache to redirect HTTP requests to HTTPS requests or to require that viewers use only the HTTPS protocol to access your objects in the CloudFront cache. You should also configure one or more cache behaviors in the same distribution to allow both HTTP and HTTPS, so you can require HTTPS for some objects but not for others.

  In order to use HTTPS, a SSL\TLS certificate must be attached.

  This depends on your data classification policy and needs to be configured according to your encryption policy.
To ensure that objects are encrypted from edge locations to viewers using HTTP or HTTPS depending on your data classification and encryption policies, use only HTTPS."
  solution    : "Using the Amazon unified command line interface:

* For configuring \"ViewerProtocolPolicy\" first save locally the current distribution config:

  aws cloudfront get-distribution-config --id <application_cfn_distribution_id> --query \"DistributionConfig\" > /tmp/cf-distribution.json

* Edit and replace \"ViewerProtocolPolicy\" element in /tmp/cf-distribution.json with the below section:

  \"ViewerProtocolPolicy\": \"redirect-to-https\",

* Retrieve the current ETag of your CloudFront distribution:

  aws cloudfront get-distribution-config --id <application_cfn_distribution_id> --query \"ETag\"

* Update the CloudFront distribution using the edited config and the above Etag:

  aws cloudfront update-distribution --id <application_cfn_distribution_id> --distribution-config file:///tmp/cf-distribution.json --if-match <application_cfn_distribution_etag>"
  reference   : "800-171|3.13.1,800-171|3.13.5,800-53|SC-7,CN-L3|8.1.10.6(j),CSF|DE.CM-1,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,LEVEL|2S,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,TBA-FIISB|43.1"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "ListDistributions"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//cloudfront:Items\">"
  xsl_stmt    : "<xsl:for-each select=\"//cloudfront:Items/cloudfront:DistributionSummary\">"
  xsl_stmt    : "<xsl:value-of select=\"cloudfront:Id\"/><xsl:text> : Viewer Protocol Policy = </xsl:text><xsl:value-of select=\"cloudfront:DefaultCacheBehavior/cloudfront:ViewerProtocolPolicy\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Viewer Protocol Policy Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : ".* : Viewer Protocol Policy ="
  not_expect  : ".* : Viewer Protocol Policy = allow-all"
</custom_item>

<custom_item>
  type        : CLOUDFRONT
  description : "3.13 Ensure all CloudFront Distributions require HTTPS between CloudFront and your Web-Tier ELB origin"
  info        : "Configure the Origin Protocol Policy for the Web tier ELB origin either to require that CloudFront fetches objects from your origin by using HTTPS or to require that CloudFront uses the protocol that the viewer used to request the objects. For example, if you choose Match Viewer for the Origin Protocol Policy and the viewer uses HTTPS to request an object from CloudFront, CloudFront also uses HTTPS to forward the request to your origin.

  In order to use HTTPS, an SSL\TLS certificate must be attached.
To ensure that objects are encrypted from edge locations to the Web-Tier ELB origin according to the data classification policy, use Match Viewer."
  solution    : "Using the Amazon unified command line interface:

* For configuring \"OriginProtocolPolicy\"first save locally the current distribution config:

  aws cloudfront get-distribution-config --id <application_cfn_distribution_id> --query \"DistributionConfig\" > /tmp/cf-distribution.json

* Edit and replace \"OriginProtocolPolicy\"element in /tmp/cf-distribution.json with the below section:

  \"OriginProtocolPolicy\": \"https-only\",

* Retrieve the current ETag of your CloudFront distribution:

  aws cloudfront get-distribution-config --id <application_cfn_distribution_id> --query \"ETag\"

* Update the CloudFront distribution using the edited config and the above Etag:

  aws cloudfront update-distribution --id <application_cfn_distribution_id> --distribution-config file:///tmp/cf-distribution.json --if-match <application_cfn_distribution_etag>"
  reference   : "800-171|3.13.8,800-53|SC-8(1),CSF|PR.DS-2,CSF|PR.DS-5,ISO/IEC-27001|A.10.1.1,ISO/IEC-27001|A.13.2.3,ITSG-33|SC-8(1),LEVEL|2S,NESA|T7.4.1,NIAv2|NS5d,NIAv2|NS6b,SWIFT-CSCv1|2.1,TBA-FIISB|29.1"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "ListDistributions"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//cloudfront:Items\">"
  xsl_stmt    : "<xsl:for-each select=\"//cloudfront:Items/cloudfront:DistributionSummary\">"
  xsl_stmt    : "<xsl:value-of select=\"cloudfront:Id\"/><xsl:text> : Origin Protocol Policy = </xsl:text><xsl:value-of select=\"cloudfront:Origins/cloudfront:Items/cloudfront:Origin/cloudfront:CustomOriginConfig/cloudfront:OriginProtocolPolicy\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Origin Protocol Policy Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : ".* : Origin Protocol Policy ="
  not_expect  : ".* : Origin Protocol Policy = (http-only|match-viewer)"
</custom_item>

<custom_item>
  type        : ROUTE53
  description : "6.1 Ensure Root Domain Alias Record Points to ELB"
  info        : "Amazon Route 53 translates friendly domains names like www.example.com into IP addresses like 192.0.2.1. Amazon Route 53 responds to DNS queries using a global network of authoritative DNS servers, which reduces latency.

  When someone enters your domain name in a browser, a DNS request is forwarded to the nearest Amazon Route 53 DNS server in a global network of authoritative DNS servers. Amazon Route 53 responds with the IP address that you specified.

  Each domain has an associated hosted zone which contains the resource records pointing to each layer of the application.

  A private hosted zone is a container that holds information about how you want to route traffic for a domain and its subdomains within the Amazon Virtual Private Cloud (Amazon VPC). To begin, you create a private hosted zone and specify the Amazon VPCs that you want to associate with the hosted zone. You then create resource record sets that determine how Amazon Route 53 responds to queries for your domain and subdomains within and among your Amazon VPCs.
Route53 provides special record type called Alias that allow to create an A record for the root domain and point it to the fully qualified domain of the Elastic Load Balancer (ELB) associated with the web-server layer or Amazon CloudFront.

  In the same way records for all other layers should be created in order to allow flexibility in the application design and not hard-code the FQDN of a resource."
  solution    : "Using the Amazon unified command line interface:

* Create a hosted zone for YourDomain.com:

  aws route53 create-hosted-zone --name <y_our_domain.com>_ --caller-reference _<any_string>_"
  reference   : "800-53|SC-20,ITSG-33|SC-20,LEVEL|2S"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "ListHostedZones"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//route53:HostedZones\">"
  xsl_stmt    : "<xsl:for-each select=\"//route53:HostedZones/route53:HostedZone\">"
  xsl_stmt    : "<xsl:text>Hosted Zone ID = </xsl:text><xsl:value-of select=\"route53:Id\"/><xsl:text> - Domain Name = </xsl:text><xsl:value-of select=\"route53:Name\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Hosted Zones Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : "Hosted Zone ID ="
  expect      : "Hosted Zone ID = .* - Domain Name = .*"
</custom_item>

<custom_item>
  type           : ROUTE53
  description    : "6.2 Ensure a DNS alias record for the root domain"
  info           : "While ordinary Amazon Route 53 resource record sets are standard DNS resource record sets, _alias resource record sets_ provide an Amazon Route 53-specific extension to DNS functionality. Instead of an IP address or a domain name, an alias resource record set contains a pointer to a CloudFront distribution or an ELB load balancer.

  Alias resource record sets can save you time because Amazon Route 53 automatically recognizes changes in the resource record sets that the alias resource record set refers to.
In order to point the root domain to a CloudFront distribution or an Elastic Load Balancer (ELB), an alias resource record set should be created."
  solution       : "First create a json file that represents the alias record that you want to add, and save it locally as \"alias.json\". Below you can find a simple alias record representation:

  {
 \"Changes\": [
 {
 \"Action\": \"CREATE\",
 \"ResourceRecordSet\": {
 \"Name\": \"_<your_root_domain>_\",
 \"Type\": \"A\",
 \"AliasTarget\": {
 \"HostedZoneId\": \"hosted zone ID for your CloudFront distribution, Amazon S3 bucket, Elastic Load Balancing load balancer, or Amazon Route 53 hosted zone\",
 \"DNSName\": \"DNS domain name for your CloudFront distribution, Amazon S3 bucket, Elastic Load Balancing load balancer, or another resource record set in this hosted zone\",
 \"EvaluateTargetHealth\": false
 }
 }
 }
 ]
}

  Using the Amazon unified command line interface:

* Create an Alias records in your hosted zone:

  aws route53 change-resource-record-sets --hosted-zone-id <_your_hosted_zone_id>_ --change-batch file:///PathTo/alias.json"
  reference      : "800-53|SC-20,ITSG-33|SC-20,LEVEL|2S"
  see_also       : "https://workbench.cisecurity.org/files/260"
  aws_action     : "ListResourceRecordSets"
  xsl_stmt       : "<xsl:template match=\"/\">"
  xsl_stmt       : "<xsl:choose>"
  xsl_stmt       : "<xsl:when test=\"//route53:ResourceRecordSets/route53:ResourceRecordSet\">"
  xsl_stmt       : "<xsl:for-each select=\"//route53:ResourceRecordSets/route53:ResourceRecordSet/route53:AliasTarget\">"
  xsl_stmt       : "<xsl:text>Hosted Zone ID = </xsl:text><xsl:value-of select=\"route53:HostedZoneId\"/><xsl:text> - DNS Name = </xsl:text><xsl:value-of select=\"route53:DNSName\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt       : "</xsl:for-each>"
  xsl_stmt       : "</xsl:when>"
  xsl_stmt       : "<xsl:otherwise>"
  xsl_stmt       : "<xsl:text>Hosted Zones Not Found</xsl:text>"
  xsl_stmt       : "</xsl:otherwise>"
  xsl_stmt       : "</xsl:choose>"
  xsl_stmt       : "</xsl:template>"
  regex          : "Hosted Zone ID ="
  expect         : "Hosted Zone ID = .* - DNS Name = .*"
# Note: Variable @HOSTED_ZONE_ID@ replaced with "HOSTED_ZONE_ID" in field "hosted_zone_id".
  hosted_zone_id : "HOSTED_ZONE_ID"
</custom_item>

<custom_item>
  type        : CLOUDFRONT
  description : "6.4 Ensure Geo-Restriction is enabled within Cloudfront Distribution"
  info        : "Amazon CloudFront is a web service that speeds up distribution of your static and dynamic web content, for example, .html, .css, .php, image, and media files, to end users. CloudFront delivers your content through a worldwide network of edge locations. When an end user requests content that you're serving with CloudFront, the user is routed to the edge location that provides the lowest latency, so content is delivered with the best possible performance. If the content is already in that edge location, CloudFront delivers it immediately. If the content is not currently in that edge location, CloudFront retrieves it from a customer defined Origin, such as AWS S3, AWS ELB or EC2.
Provides the ability to block IP addresses based on Geo IP from reaching your CDN or Web Application resources. Can be used to assist in mitigation of DoS attacks."
  solution    : "Using the Amazon unified command line interface:

* For enabling GeoRestrictions first save locally the current distribution config:

  aws cloudfront get-distribution-config --id _<application_cfn_distribution_id_> --query \"DistributionConfig\" > /tmp/cf-distribution.json

* Edit the GeoRestrictions section in /tmp/cf-distribution.json with the desired configuration (similar to the below sample):

  \"Restrictions\": {
 \"GeoRestriction\": {
 \"RestrictionType\": \"_<blacklist|whitelist>_\",
 \"Quantity\": 3,
 \"Items\": [\"_<country_code_1>_\", \"_<country_code_2>_\"]
 }
},

* Retrieve the current ETag of your CloudFront distribution:

  aws cloudfront get-distribution-config --id _<application_cfn_distribution_id_> --query \"ETag\"

* Update the CloudFront distribution using the edited config and the above Etag:

  aws cloudfront update-distribution --id _<application_cfn_distribution_id_> --distribution-config file:///tmp/cf-distribution.json --if-match _<application_cfn_distribution_etag_>"
  reference   : "800-171|3.13.1,800-53|SC-7(11),CSF|PR.AC-5,CSF|PR.PT-4,ITSG-33|SC-7(11),LEVEL|2S,NIAv2|GS7c,TBA-FIISB|31.3"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "ListDistributions"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//cloudfront:Items\">"
  xsl_stmt    : "<xsl:for-each select=\"//cloudfront:Items/cloudfront:DistributionSummary\">"
  xsl_stmt    : "<xsl:value-of select=\"cloudfront:Id\"/><xsl:text> : GeoRestriction = </xsl:text><xsl:value-of select=\"cloudfront:Restrictions/cloudfront:GeoRestriction/cloudfront:RestrictionType\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>GeoRestriction Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : ".* : GeoRestriction ="
  not_expect  : ".* : GeoRestriction = none"
</custom_item>

<custom_item>
  type        : RDS
  description : "6.30 Ensure RDS Database is not publically accessible"
  info        : "Amazon Relational Database Service (RDS) is a managed relational database service which handles routine database tasks such as provisioning, patching, backup, recovery, failure detection, and repair.

  There are 6 database engines available for customer to run their database workloads on:

* Amazon Aurora (MySQL Compatible)
* MySQL
* MariaDB
* Oracle
* Microsoft SQL Server
* PostgreSQL

  Customers can deploy RDS databases within a VPC through the configuration of:

* Subnet Group for RDS, this group will be used for deployment of single or Multi-AZ RDS instances.
* Network access through configuration of Security Groups for RDS
* Access from outside the VPC hosting the DB instance by enabling/disabling a Public IP address
Network access to the managed Data-Tier must be tightly controlled using Security Groups for RDS and non local accessibility of the DB instance."
  solution    : "Using the Amazon unified command line interface:

* Modify each publicly accessible DB instance, and make it private:

  aws rds modify-db-instance --db-instance-identifier <your_db_instance> --no-publicly-accessible"
  reference   : "800-171|3.13.1,800-171|3.13.5,800-53|SC-7,CN-L3|8.1.10.6(j),CSF|DE.CM-1,CSF|PR.AC-5,CSF|PR.DS-5,CSF|PR.PT-4,ISO/IEC-27001|A.13.1.3,ITSG-33|SC-7,LEVEL|2S,NESA|T4.5.4,NIAv2|GS1,NIAv2|GS2a,NIAv2|GS2b,TBA-FIISB|43.1"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "DescribeDBInstances"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//rds:DBInstances\">"
# Note: Variable @DB_INSTANCE_IDENTIFIER@ replaced with "DB_INSTANCE_IDENTIFIER" in field "xsl_stmt".
  xsl_stmt    : "<xsl:for-each select=\"//rds:DBInstances/rds:DBInstance[rds:DBInstanceIdentifier = 'DB_INSTANCE_IDENTIFIER']\">"
  xsl_stmt    : "<xsl:text>Publicly Accessible = </xsl:text><xsl:value-of select=\"rds:PubliclyAccessible\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Publicly Accessible Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : "Publicly Accessible ="
  expect      : "Publicly Accessible = false"
</custom_item>

<custom_item>
  type        : EC2
  description : "6.31 Don't use the default VPC"
  info        : "A default VPC is ready for you to use -- you can immediately start launching instances into your default VPC without having to perform any additional configuration steps.

  When we create a default VPC, AWS does the following to set it up:

* Create a default subnet in each Availability Zone.
* Create an Internet gateway and connect it to your default VPC.
* Create a main route table for your default VPC with a rule that sends all traffic destined for the Internet to the Internet gateway.
* Create a default security group and associate it with your default VPC.
* Create a default network access control list (ACL) and associate it with your default VPC.
* Associate the default DHCP options set for your AWS account with your default VPC.

  Label this Default VPC \"Do Not Use\".
The default VPC comes with some default configuration that wouldn't meet the best practices, however if recommended setting are created or the default behavior is changed, this would still be considered ok."
  solution    : "Using the Amazon Unified CLI:

* Create a new VPC with the desired CIDR and migrate your application:

  aws ec2 create-vpc --cidr-block _<desired_cidr>_"
  reference   : "LEVEL|2S"
  see_also    : "https://workbench.cisecurity.org/files/260"
  aws_action  : "DescribeVpcs"
  xsl_stmt    : "<xsl:template match=\"/\">"
  xsl_stmt    : "<xsl:choose>"
  xsl_stmt    : "<xsl:when test=\"//ec2:vpcSet\">"
  xsl_stmt    : "<xsl:for-each select=\"//ec2:vpcSet/ec2:item\">"
  xsl_stmt    : "<xsl:text>VPC ID = </xsl:text><xsl:value-of select=\"ec2:vpcId\"/><xsl:text> | Is Dafault = </xsl:text><xsl:value-of select=\"ec2:isDefault\"/><xsl:text>&#10;</xsl:text>"
  xsl_stmt    : "</xsl:for-each>"
  xsl_stmt    : "</xsl:when>"
  xsl_stmt    : "<xsl:otherwise>"
  xsl_stmt    : "<xsl:text>Is Dafault Not Found</xsl:text>"
  xsl_stmt    : "</xsl:otherwise>"
  xsl_stmt    : "</xsl:choose>"
  xsl_stmt    : "</xsl:template>"
  regex       : "VPC ID = .* \| Is Dafault ="
  expect      : "VPC ID = .* \| Is Dafault = false"
</custom_item>

</check_type>
